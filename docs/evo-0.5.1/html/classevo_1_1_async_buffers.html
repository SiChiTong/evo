<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Evo C++ Library v0.5.1: AsyncBuffers Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evo C++ Library v0.5.1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceevo.html">evo</a></li><li class="navelem"><a class="el" href="classevo_1_1_async_buffers.html">AsyncBuffers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classevo_1_1_async_buffers-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AsyncBuffers Class Reference<div class="ingroups"><a class="el" href="group___evo_i_o.html">EvoIO</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ioasync__base_8h_source.html">evo/ioasync_base.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds data for async I/O buffers (used internally with <a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a> and protocol implementations). </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers_1_1_bulk_write.html">BulkWrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to group multiple writes for efficiency.  <a href="classevo_1_1_async_buffers_1_1_bulk_write.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ee6d3dc80c860817d35f9f29339a126"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a9ee6d3dc80c860817d35f9f29339a126">AsyncBuffers</a> ()</td></tr>
<tr class="memdesc:a9ee6d3dc80c860817d35f9f29339a126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (used internally).  <a href="#a9ee6d3dc80c860817d35f9f29339a126">More...</a><br /></td></tr>
<tr class="separator:a9ee6d3dc80c860817d35f9f29339a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7c0667f4d44bbeeaf80771455e9178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a2b7c0667f4d44bbeeaf80771455e9178">attach</a> (struct bufferevent *bev)</td></tr>
<tr class="memdesc:a2b7c0667f4d44bbeeaf80771455e9178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to active buffers (used internally).  <a href="#a2b7c0667f4d44bbeeaf80771455e9178">More...</a><br /></td></tr>
<tr class="separator:a2b7c0667f4d44bbeeaf80771455e9178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38780edcc01cd61d656791f8646e18c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#ab38780edcc01cd61d656791f8646e18c">attach_read</a> ()</td></tr>
<tr class="memdesc:ab38780edcc01cd61d656791f8646e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to current write buffers for reading too (used internally).  <a href="#ab38780edcc01cd61d656791f8646e18c">More...</a><br /></td></tr>
<tr class="separator:ab38780edcc01cd61d656791f8646e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6547fdc18b49326786ccc4fee7d1f444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a6547fdc18b49326786ccc4fee7d1f444">attach_write</a> (struct bufferevent *bev)</td></tr>
<tr class="memdesc:a6547fdc18b49326786ccc4fee7d1f444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to active buffers for writing (used internally).  <a href="#a6547fdc18b49326786ccc4fee7d1f444">More...</a><br /></td></tr>
<tr class="separator:a6547fdc18b49326786ccc4fee7d1f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363447c8872c976f22a7052e8fc1c727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a363447c8872c976f22a7052e8fc1c727">read_fixed</a> (<a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;data, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> size, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> max_size=0)</td></tr>
<tr class="memdesc:a363447c8872c976f22a7052e8fc1c727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read fixed size data from read buffer.  <a href="#a363447c8872c976f22a7052e8fc1c727">More...</a><br /></td></tr>
<tr class="separator:a363447c8872c976f22a7052e8fc1c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74a87caea63f3372201fb343b9924d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa74a87caea63f3372201fb343b9924d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#aa74a87caea63f3372201fb343b9924d2">read_fixed_helper</a> (T &amp;parent, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> &amp;fixed_size, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> size, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> max_size=0, void *context=NULL)</td></tr>
<tr class="memdesc:aa74a87caea63f3372201fb343b9924d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for reading fixed size data from read buffer from a ProtocolHandler <code>on_read()</code> event.  <a href="#aa74a87caea63f3372201fb343b9924d2">More...</a><br /></td></tr>
<tr class="separator:aa74a87caea63f3372201fb343b9924d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583b28521d1bfb1de8bda9ec0bd60e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a583b28521d1bfb1de8bda9ec0bd60e95">read_flush</a> ()</td></tr>
<tr class="memdesc:a583b28521d1bfb1de8bda9ec0bd60e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush and consume next line from read buffer.  <a href="#a583b28521d1bfb1de8bda9ec0bd60e95">More...</a><br /></td></tr>
<tr class="separator:a583b28521d1bfb1de8bda9ec0bd60e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05bafcf4897ca844f064cadcb30a756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#ad05bafcf4897ca844f064cadcb30a756">read_line</a> (<a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;data)</td></tr>
<tr class="memdesc:ad05bafcf4897ca844f064cadcb30a756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next line from read buffer.  <a href="#ad05bafcf4897ca844f064cadcb30a756">More...</a><br /></td></tr>
<tr class="separator:ad05bafcf4897ca844f064cadcb30a756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2eddfa06697dccb0ae14a22d68db68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#aed2eddfa06697dccb0ae14a22d68db68">read_reset</a> (size_t max_size, size_t min_size=0)</td></tr>
<tr class="memdesc:aed2eddfa06697dccb0ae14a22d68db68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset read buffer thresholds.  <a href="#aed2eddfa06697dccb0ae14a22d68db68">More...</a><br /></td></tr>
<tr class="separator:aed2eddfa06697dccb0ae14a22d68db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eef5b4dca06f0888c70d765e4b3eac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a29eef5b4dca06f0888c70d765e4b3eac">read_size</a> ()</td></tr>
<tr class="memdesc:a29eef5b4dca06f0888c70d765e4b3eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read buffer data size in bytes.  <a href="#a29eef5b4dca06f0888c70d765e4b3eac">More...</a><br /></td></tr>
<tr class="separator:a29eef5b4dca06f0888c70d765e4b3eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset buffer pointers (used internally).  <a href="#ad20897c5c8bd47f5d4005989bead0e55">More...</a><br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c67c0936060cf6369977b6f06dee90d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a5c67c0936060cf6369977b6f06dee90d">write</a> (const char *data, size_t size)</td></tr>
<tr class="separator:a5c67c0936060cf6369977b6f06dee90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317d6465afb5dcb1eaade6e5eca6fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a3317d6465afb5dcb1eaade6e5eca6fab">write_clear</a> ()</td></tr>
<tr class="separator:a3317d6465afb5dcb1eaade6e5eca6fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0e98f65403ee308951dfa862661fb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a1e0e98f65403ee308951dfa862661fb9">write_reserve</a> (size_t size)</td></tr>
<tr class="separator:a1e0e98f65403ee308951dfa862661fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b22974fe8dd47527efeebce3cd9af7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_async_buffers.html#a1b22974fe8dd47527efeebce3cd9af7e">write_size</a> () const</td></tr>
<tr class="separator:a1b22974fe8dd47527efeebce3cd9af7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9ee6d3dc80c860817d35f9f29339a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee6d3dc80c860817d35f9f29339a126">&#9670;&nbsp;</a></span>AsyncBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_async_buffers.html">AsyncBuffers</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor (used internally). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2b7c0667f4d44bbeeaf80771455e9178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7c0667f4d44bbeeaf80771455e9178">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attach </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to active buffers (used internally). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bev</td><td>Buffers to attach to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab38780edcc01cd61d656791f8646e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38780edcc01cd61d656791f8646e18c">&#9670;&nbsp;</a></span>attach_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attach_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to current write buffers for reading too (used internally). </p>

</div>
</div>
<a id="a6547fdc18b49326786ccc4fee7d1f444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6547fdc18b49326786ccc4fee7d1f444">&#9670;&nbsp;</a></span>attach_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attach_write </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to active buffers for writing (used internally). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bev</td><td>Buffers to attach to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a363447c8872c976f22a7052e8fc1c727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363447c8872c976f22a7052e8fc1c727">&#9670;&nbsp;</a></span>read_fixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool read_fixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read fixed size data from read buffer. </p>
<ul>
<li>This references buffered data directly (no copy)</li>
<li>If not enough data available, call again on next read event &ndash; see <a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a><ul>
<li>If the first call fails, this will adjust internal read thresholds so the next read event has enough data</li>
</ul>
</li>
<li>On success, must call <a class="el" href="classevo_1_1_async_buffers.html#a583b28521d1bfb1de8bda9ec0bd60e95" title="Flush and consume next line from read buffer. ">read_flush()</a> to actually consume the data (removing it from read buffer), then if it took 2 calls (previous <a class="el" href="classevo_1_1_async_buffers.html#a363447c8872c976f22a7052e8fc1c727" title="Read fixed size data from read buffer. ">read_fixed()</a> call failed), must call <a class="el" href="classevo_1_1_async_buffers.html#aed2eddfa06697dccb0ae14a22d68db68" title="Reset read buffer thresholds. ">read_reset()</a> to reset read thresholds</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Set to reference data from read buffer on success [out] </td></tr>
    <tr><td class="paramname">size</td><td>Data size to read </td></tr>
    <tr><td class="paramname">max_size</td><td>Max read buffer size, 0 for no limit, must be at least enough for size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether successful, false if not enough received yet so call again on next read event </dd></dl>

</div>
</div>
<a id="aa74a87caea63f3372201fb343b9924d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74a87caea63f3372201fb343b9924d2">&#9670;&nbsp;</a></span>read_fixed_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool read_fixed_helper </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> &amp;&#160;</td>
          <td class="paramname"><em>fixed_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for reading fixed size data from read buffer from a ProtocolHandler <code>on_read()</code> event. </p>
<ul>
<li>This helps properly implement a pattern where an <code>on_read()</code> event needs to read fixed size data<ul>
<li>This is a bit tricky because I/O is asynchronous and we may or may not need to wait for more data, creating 2 code paths</li>
<li>The idea here is to use <code>parent.on_fixed_read()</code> to handle both code paths</li>
<li>See <a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a> for more on this</li>
</ul>
</li>
<li>If enough data has been received then this:<ul>
<li>Reads the data with <a class="el" href="classevo_1_1_async_buffers.html#a363447c8872c976f22a7052e8fc1c727" title="Read fixed size data from read buffer. ">read_fixed()</a>, calls <code>parent.on_read_fixed()</code> to consume it, then calls <a class="el" href="classevo_1_1_async_buffers.html#a583b28521d1bfb1de8bda9ec0bd60e95" title="Flush and consume next line from read buffer. ">read_flush()</a> to flush this data</li>
<li>The above is repeated in a loop as long as enough data is available, and <code>parent.on_read_fixed()</code> sets <code>next_size</code> to read another chunk of fixed data</li>
</ul>
</li>
<li>If enough data is not available, this sets <code>fixed_size</code> and returns true</li>
<li>If this returns true and:<ul>
<li><code>fixed_size &gt; 0</code>: the calling <code>on_read()</code> function should immediately return true to wait for more data</li>
<li>else: the data has been read and processed, and the calling <code>on_read()</code> function may continue reading and processing data</li>
</ul>
</li>
<li>If a call to <code>parent.on_read_fixed()</code> returns false, this will immediately return false, and the calling <code>on_read()</code> function should also immediately return false to close the connection</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parent ProtocolHandler type with <code>on_read()</code> and <code>on_read_fixed()</code> event methods (inferred from parent)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent ProtocolHandler calling this from <code>on_read()</code> event method </td></tr>
    <tr><td class="paramname">fixed_size</td><td>Reference to <code>fixed_size</code> param passed to <code>on_read()</code> </td></tr>
    <tr><td class="paramname">size</td><td>Data size to read </td></tr>
    <tr><td class="paramname">max_size</td><td>Max read buffer size, 0 for no limit, must be at least enough for <code>size</code> </td></tr>
    <tr><td class="paramname">context</td><td>Context pointer for deferred server reply (used with servers), NULL for clients &ndash; passed to <code>on_read_fixed()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether successful, true and <code>fixed_size &gt; 0</code> if need to wait for more data, otherwise true if data processed, false to close connection immediately</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>This example reads a line with a data size, then does a fixed-size read on that data size.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> on_read(<span class="keywordtype">size_t</span>&amp; fixed_size, <a class="code" href="classevo_1_1_async_buffers.html#a9ee6d3dc80c860817d35f9f29339a126">AsyncBuffers</a>&amp; buffers, <span class="keywordtype">void</span>* context) {</div><div class="line">    SubString line;</div><div class="line">    <span class="keywordflow">while</span> (buffers.read_line(line)) {</div><div class="line">        uint data_size = line.numu().value();</div><div class="line">        buffers.read_flush();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (data_size &gt; 0) {</div><div class="line">            <span class="keywordflow">if</span> (!buffers.read_fixed_helper(*<span class="keyword">this</span>, fixed_size, data_size, 0, context))</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keywordflow">if</span> (fixed_size &gt; 0)</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// wait for more data</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a583b28521d1bfb1de8bda9ec0bd60e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583b28521d1bfb1de8bda9ec0bd60e95">&#9670;&nbsp;</a></span>read_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush and consume next line from read buffer. </p>
<ul>
<li>Must call <a class="el" href="classevo_1_1_async_buffers.html#ad05bafcf4897ca844f064cadcb30a756" title="Read next line from read buffer. ">read_line()</a> first to get next line</li>
<li>Only call this after <a class="el" href="classevo_1_1_async_buffers.html#ad05bafcf4897ca844f064cadcb30a756" title="Read next line from read buffer. ">read_line()</a> returns true </li>
</ul>

</div>
</div>
<a id="ad05bafcf4897ca844f064cadcb30a756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05bafcf4897ca844f064cadcb30a756">&#9670;&nbsp;</a></span>read_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool read_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next line from read buffer. </p>
<ul>
<li>This references buffered data directly (no copy)</li>
<li>On success, must call <a class="el" href="classevo_1_1_async_buffers.html#a583b28521d1bfb1de8bda9ec0bd60e95" title="Flush and consume next line from read buffer. ">read_flush()</a> to actually consume the data (removing it from read buffer)</li>
<li>If not enough data available, call again on next read event</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Set to reference next line from read buffer [out] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether successful, false if no newline received yet so call again on next read event </dd></dl>

</div>
</div>
<a id="aed2eddfa06697dccb0ae14a22d68db68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2eddfa06697dccb0ae14a22d68db68">&#9670;&nbsp;</a></span>read_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read_reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset read buffer thresholds. </p>
<ul>
<li>This sets the read buffer min/max thresholds (also known as watermarks) as conditions for calling the next read event</li>
<li>Call to prepare for next read</li>
<li>See <a class="el" href="classevo_1_1_async_buffers.html#a363447c8872c976f22a7052e8fc1c727" title="Read fixed size data from read buffer. ">read_fixed()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>Maximum read buffer size, stop reading from socket when buffer hits this size, 0 for no max </td></tr>
    <tr><td class="paramname">min_size</td><td>Minimum read buffer size, read event isn't called until this size is reached, 0 for any size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29eef5b4dca06f0888c70d765e4b3eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eef5b4dca06f0888c70d765e4b3eac">&#9670;&nbsp;</a></span>read_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t read_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read buffer data size in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Buffered data size </dd></dl>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset buffer pointers (used internally). </p>

</div>
</div>
<a id="a5c67c0936060cf6369977b6f06dee90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c67c0936060cf6369977b6f06dee90d">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3317d6465afb5dcb1eaade6e5eca6fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3317d6465afb5dcb1eaade6e5eca6fab">&#9670;&nbsp;</a></span>write_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e0e98f65403ee308951dfa862661fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0e98f65403ee308951dfa862661fb9">&#9670;&nbsp;</a></span>write_reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write_reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b22974fe8dd47527efeebce3cd9af7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b22974fe8dd47527efeebce3cd9af7e">&#9670;&nbsp;</a></span>write_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t write_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>evo/<a class="el" href="ioasync__base_8h_source.html">ioasync_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 7 2019 18:17:32 for Evo C++ Library v0.5.1 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
