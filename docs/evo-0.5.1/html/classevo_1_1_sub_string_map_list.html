<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Evo C++ Library v0.5.1: SubStringMapList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evo C++ Library v0.5.1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceevo.html">evo</a></li><li class="navelem"><a class="el" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classevo_1_1_sub_string_map_list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SubStringMapList Class Reference<div class="ingroups"><a class="el" href="group___evo_containers.html">EvoContainers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="substring_8h_source.html">evo/substring.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>References a list of sorted substrings for fast lookup. </p>
<ul>
<li>Lookups are done with binary search</li>
<li><b>Caution:</b> String list <em>must be sorted</em> for <code>find</code> methods to work correctly</li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="enum_8h.html">evo/enum.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Pre-sorted string list (no mem allocs)</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a> LIST[] = {</div><div class="line">        <span class="stringliteral">&quot;bar&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;foo&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;stuff&quot;</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Efficient map from string list (no mem allocs, binary search)</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> LISTMAP(LIST, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a>(LIST));</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i1 = LISTMAP.find(<span class="stringliteral">&quot;foo&quot;</span>);       <span class="comment">// set to 1</span></div><div class="line">    <span class="keywordtype">int</span> i2 = LISTMAP.find(<span class="stringliteral">&quot;baz&quot;</span>);       <span class="comment">// set to NONE (not found)</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_sub_string_map_list_1_1_reverse_remap.html">ReverseRemap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a reversed enum value remap array for fast reverse lookups.  <a href="structevo_1_1_sub_string_map_list_1_1_reverse_remap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3febbd92fd1129bfeaf85251c2b1583"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#ab3febbd92fd1129bfeaf85251c2b1583">SubStringMapList</a> ()</td></tr>
<tr class="memdesc:ab3febbd92fd1129bfeaf85251c2b1583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for null and empty <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> list.  <a href="#ab3febbd92fd1129bfeaf85251c2b1583">More...</a><br /></td></tr>
<tr class="separator:ab3febbd92fd1129bfeaf85251c2b1583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae661dee91963e980ca4208836c73f14d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#ae661dee91963e980ca4208836c73f14d">SubStringMapList</a> (const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> *<a class="el" href="classevo_1_1_sub_string_map_list.html#a199deba77218e1ed06c16c666e0a8430">data</a>, <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> <a class="el" href="classevo_1_1_sub_string_map_list.html#a9e0a87be0fb461bebd7a8b1a99c071e0">size</a>, bool verify_order=false)</td></tr>
<tr class="memdesc:ae661dee91963e980ca4208836c73f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for referencing an existing <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> list.  <a href="#ae661dee91963e980ca4208836c73f14d">More...</a><br /></td></tr>
<tr class="separator:ae661dee91963e980ca4208836c73f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199deba77218e1ed06c16c666e0a8430"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a199deba77218e1ed06c16c666e0a8430">data</a> () const</td></tr>
<tr class="memdesc:a199deba77218e1ed06c16c666e0a8430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to map string values.  <a href="#a199deba77218e1ed06c16c666e0a8430">More...</a><br /></td></tr>
<tr class="separator:a199deba77218e1ed06c16c666e0a8430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether empty.  <a href="#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e30eca68bcdfdf92c5337e735632d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a5e30eca68bcdfdf92c5337e735632d0c">find</a> (const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;key) const</td></tr>
<tr class="memdesc:a5e30eca68bcdfdf92c5337e735632d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find key string in list.  <a href="#a5e30eca68bcdfdf92c5337e735632d0c">More...</a><br /></td></tr>
<tr class="separator:a5e30eca68bcdfdf92c5337e735632d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cc3a1193edb8d3ae8bb9707eccbc79"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a35cc3a1193edb8d3ae8bb9707eccbc79"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a35cc3a1193edb8d3ae8bb9707eccbc79">find_enum</a> (const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;key, T first_enum, T last_enum, T unknown) const</td></tr>
<tr class="memdesc:a35cc3a1193edb8d3ae8bb9707eccbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find key string in list and convert to enum value.  <a href="#a35cc3a1193edb8d3ae8bb9707eccbc79">More...</a><br /></td></tr>
<tr class="separator:a35cc3a1193edb8d3ae8bb9707eccbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8fc1e851206fd1674ecb6da863e7c5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b8fc1e851206fd1674ecb6da863e7c5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a1b8fc1e851206fd1674ecb6da863e7c5">find_enum_class</a> (const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;key) const</td></tr>
<tr class="memdesc:a1b8fc1e851206fd1674ecb6da863e7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find key string in list and convert to enum class value (C++11).  <a href="#a1b8fc1e851206fd1674ecb6da863e7c5">More...</a><br /></td></tr>
<tr class="separator:a1b8fc1e851206fd1674ecb6da863e7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359115ad4bcf5ea2da0fd24a11f0c15c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a359115ad4bcf5ea2da0fd24a11f0c15c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a359115ad4bcf5ea2da0fd24a11f0c15c">find_enum_remap</a> (const T *remap_array, const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;key, T first_enum, T last_enum, T unknown) const</td></tr>
<tr class="memdesc:a359115ad4bcf5ea2da0fd24a11f0c15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find key string in list and convert to enum value, with unsorted enum remapped to sorted values.  <a href="#a359115ad4bcf5ea2da0fd24a11f0c15c">More...</a><br /></td></tr>
<tr class="separator:a359115ad4bcf5ea2da0fd24a11f0c15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9994869c767c450ba95d7ef5fc92399"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab9994869c767c450ba95d7ef5fc92399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structevo_1_1_sub_string.html">SubString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#ab9994869c767c450ba95d7ef5fc92399">get_enum_class_string</a> (T enum_value) const</td></tr>
<tr class="memdesc:ab9994869c767c450ba95d7ef5fc92399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert enum class value to key string from list (C++11).  <a href="#ab9994869c767c450ba95d7ef5fc92399">More...</a><br /></td></tr>
<tr class="separator:ab9994869c767c450ba95d7ef5fc92399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097d4e3c574980ad259a060eea9bf4ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a097d4e3c574980ad259a060eea9bf4ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structevo_1_1_sub_string.html">SubString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a097d4e3c574980ad259a060eea9bf4ba">get_enum_string</a> (T enum_value, T first_enum, T last_enum) const</td></tr>
<tr class="memdesc:a097d4e3c574980ad259a060eea9bf4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert enum value to key string from list.  <a href="#a097d4e3c574980ad259a060eea9bf4ba">More...</a><br /></td></tr>
<tr class="separator:a097d4e3c574980ad259a060eea9bf4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227114595ab6e05964b9908d7fd361da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a227114595ab6e05964b9908d7fd361da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structevo_1_1_sub_string.html">SubString</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a227114595ab6e05964b9908d7fd361da">get_enum_string_remap</a> (const <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> *reverse_remap_array, T enum_value, T first_enum, T last_enum) const</td></tr>
<tr class="memdesc:a227114595ab6e05964b9908d7fd361da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert enum value to key string from list, with unsorted enum remapped to sorted values.  <a href="#a227114595ab6e05964b9908d7fd361da">More...</a><br /></td></tr>
<tr class="separator:a227114595ab6e05964b9908d7fd361da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc3ccc049f9327dc84116f44bde5c26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a5fc3ccc049f9327dc84116f44bde5c26">null</a> () const</td></tr>
<tr class="memdesc:a5fc3ccc049f9327dc84116f44bde5c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether null.  <a href="#a5fc3ccc049f9327dc84116f44bde5c26">More...</a><br /></td></tr>
<tr class="separator:a5fc3ccc049f9327dc84116f44bde5c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0a87be0fb461bebd7a8b1a99c071e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#a9e0a87be0fb461bebd7a8b1a99c071e0">size</a> () const</td></tr>
<tr class="memdesc:a9e0a87be0fb461bebd7a8b1a99c071e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of items in map.  <a href="#a9e0a87be0fb461bebd7a8b1a99c071e0">More...</a><br /></td></tr>
<tr class="separator:a9e0a87be0fb461bebd7a8b1a99c071e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbabfd2890993536117374e68617405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html#acfbabfd2890993536117374e68617405">verify</a> () const</td></tr>
<tr class="memdesc:acfbabfd2890993536117374e68617405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify strings are in correct order.  <a href="#acfbabfd2890993536117374e68617405">More...</a><br /></td></tr>
<tr class="separator:acfbabfd2890993536117374e68617405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3febbd92fd1129bfeaf85251c2b1583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3febbd92fd1129bfeaf85251c2b1583">&#9670;&nbsp;</a></span>SubStringMapList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for null and empty <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> list. </p>

</div>
</div>
<a id="ae661dee91963e980ca4208836c73f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae661dee91963e980ca4208836c73f14d">&#9670;&nbsp;</a></span>SubStringMapList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for referencing an existing <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> list. </p>
<ul>
<li>This references list data and does not allocate any memory</li>
<li>If <code>verify_order</code> is true and <a class="el" href="classevo_1_1_sub_string_map_list.html#acfbabfd2890993536117374e68617405" title="Verify strings are in correct order. ">verify()</a> fails, this throws ExceptionMapVerifyOrder</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a> data, NULL to set as null </td></tr>
    <tr><td class="paramname">size</td><td>Size as number of strings in list, 0 to set as empty </td></tr>
    <tr><td class="paramname">verify_order</td><td>Whether to verify string order with <a class="el" href="classevo_1_1_sub_string_map_list.html#acfbabfd2890993536117374e68617405" title="Verify strings are in correct order. ">verify()</a> and call abort() if this fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a199deba77218e1ed06c16c666e0a8430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199deba77218e1ed06c16c666e0a8430">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a>* data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to map string values. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to string values </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether empty </dd></dl>

</div>
</div>
<a id="a5e30eca68bcdfdf92c5337e735632d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e30eca68bcdfdf92c5337e735632d0c">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find key string in list. </p>
<ul>
<li>This uses a binary search so list must be sorted, otherwise results are accurate</li>
<li>If there are duplicate strings in list, which one is found first is undefined</li>
<li><b>Caution:</b> <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values <em>must have been sorted</em></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found key index (0 for first), NONE if not found </dd></dl>

</div>
</div>
<a id="a35cc3a1193edb8d3ae8bb9707eccbc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cc3a1193edb8d3ae8bb9707eccbc79">&#9670;&nbsp;</a></span>find_enum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T find_enum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find key string in list and convert to enum value. </p>
<ul>
<li>This uses a binary search so list must be sorted, otherwise results are inaccurate</li>
<li>This calls assert() to check the result and that the number of enum values matches the string list size</li>
<li><b>Caution:</b> <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values <em>must have been sorted</em></li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum type to convert to, inferred from arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">first_enum</td><td>First enum value to map to, maps to first string </td></tr>
    <tr><td class="paramname">last_enum</td><td>Last enum value to map to, maps to last string &ndash; must be &gt;= <code>first_enum</code> </td></tr>
    <tr><td class="paramname">unknown</td><td>Unknown enum value to use if key not found or result out of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found enum value, <code>unknown</code> if not found or out of range</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="enum_8h.html">evo/enum.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color {</div><div class="line">    cUNKNOWN = 0,</div><div class="line">    cBLUE,</div><div class="line">    cGREEN,</div><div class="line">    cRED</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a> COLORS[] = {</div><div class="line">        <span class="stringliteral">&quot;blue&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;green&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;red&quot;</span></div><div class="line">    };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> COLOR_MAP(COLORS, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a>(COLORS));</div><div class="line"></div><div class="line">    Color color = COLOR_MAP.find_enum(<span class="stringliteral">&quot;green&quot;</span>, cBLUE, cRED, cUNKNOWN);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1b8fc1e851206fd1674ecb6da863e7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8fc1e851206fd1674ecb6da863e7c5">&#9670;&nbsp;</a></span>find_enum_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T find_enum_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find key string in list and convert to enum class value (C++11). </p>
<ul>
<li>This uses a binary search so list must be sorted, otherwise results are inaccurate</li>
<li>This calls assert() to check the number of enum values matches the string list size</li>
<li>This assumes the enum class has guard values: starts with <code>T::UNKNOWN</code>, ends with <code>T::ENUM_END</code>, with at least 1 mapped value in between</li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum class type to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found enum value for key, <code>T::UNKNOWN</code> if not found</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="enum_8h.html">evo/enum.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keyword">enum class</span> Color {</div><div class="line">    UNKNOWN = 0,</div><div class="line">    BLUE,</div><div class="line">    GREEN,</div><div class="line">    RED,</div><div class="line">    ENUM_END</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a> COLORS[] = {</div><div class="line">        <a class="code" href="structevo_1_1_sub_string.html">SubString</a>(<span class="stringliteral">&quot;blue&quot;</span>),</div><div class="line">        <a class="code" href="structevo_1_1_sub_string.html">SubString</a>(<span class="stringliteral">&quot;green&quot;</span>),</div><div class="line">        <a class="code" href="structevo_1_1_sub_string.html">SubString</a>(<span class="stringliteral">&quot;red&quot;</span>)</div><div class="line">    };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> COLOR_MAP(COLORS, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a>(COLORS));</div><div class="line"></div><div class="line">    Color color = COLOR_MAP.find_enum_class&lt;Color&gt;(<span class="stringliteral">&quot;green&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a359115ad4bcf5ea2da0fd24a11f0c15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359115ad4bcf5ea2da0fd24a11f0c15c">&#9670;&nbsp;</a></span>find_enum_remap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T find_enum_remap </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>remap_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structevo_1_1_sub_string.html">SubString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find key string in list and convert to enum value, with unsorted enum remapped to sorted values. </p>
<ul>
<li>This is a variant of <a class="el" href="classevo_1_1_sub_string_map_list.html#a35cc3a1193edb8d3ae8bb9707eccbc79" title="Find key string in list and convert to enum value. ">find_enum()</a> for an unsorted enum</li>
<li>This uses <code>remap_array</code> to map an unsorted enum to sorted values &ndash; the data should be constant and static</li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum type to convert to, inferred from arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remap_array</td><td>Pointer to array of enum values sorted so they match the mapped sorted strings </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">first_enum</td><td>First enum value to map to &ndash; <em>must be first unsorted value</em> </td></tr>
    <tr><td class="paramname">last_enum</td><td>Last enum value to map to &ndash; <em>must be last unsorted value</em>, and must be &gt;= <code>first_enum</code> </td></tr>
    <tr><td class="paramname">unknown</td><td>Unknown enum value to use if key not found or result out of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found enum value, <code>unknown</code> if not found or out of range</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="enum_8h.html">evo/enum.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="comment">// Unsorted values</span></div><div class="line"><span class="keyword">enum</span> Color {</div><div class="line">    cUNKNOWN = 0,</div><div class="line">    cRED,</div><div class="line">    cGREEN,</div><div class="line">    cBLUE</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Values in sorted order</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Color COLORS_REMAP[] = {</div><div class="line">        cBLUE,</div><div class="line">        cGREEN,</div><div class="line">        cRED</div><div class="line">    };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a> COLORS[] = {</div><div class="line">        <span class="stringliteral">&quot;blue&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;green&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;red&quot;</span></div><div class="line">    };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a> COLOR_MAP(COLORS, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a>(COLORS));</div><div class="line"></div><div class="line">    Color color = COLOR_MAP.find_enum_remap(COLORS_REMAP, <span class="stringliteral">&quot;green&quot;</span>, cRED, cBLUE, cUNKNOWN);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab9994869c767c450ba95d7ef5fc92399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9994869c767c450ba95d7ef5fc92399">&#9670;&nbsp;</a></span>get_enum_class_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevo_1_1_sub_string.html">SubString</a> get_enum_class_string </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>enum_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert enum class value to key string from list (C++11). </p>
<ul>
<li>This is the reverse of <a class="el" href="classevo_1_1_sub_string_map_list.html#a1b8fc1e851206fd1674ecb6da863e7c5" title="Find key string in list and convert to enum class value (C++11). ">find_enum_class()</a></li>
<li>This assumes the enum class has guard values: starts with <code>T::UNKNOWN</code>, ends with <code>T::ENUM_END</code>, with at least 1 mapped value in between</li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum class type to use, inferred from argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_value</td><td>Enum value to convert from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String for enum value, <code>T::UNKNOWN</code> if unknown </dd></dl>

</div>
</div>
<a id="a097d4e3c574980ad259a060eea9bf4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097d4e3c574980ad259a060eea9bf4ba">&#9670;&nbsp;</a></span>get_enum_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevo_1_1_sub_string.html">SubString</a> get_enum_string </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>enum_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert enum value to key string from list. </p>
<ul>
<li>This is the reverse of <a class="el" href="classevo_1_1_sub_string_map_list.html#a35cc3a1193edb8d3ae8bb9707eccbc79" title="Find key string in list and convert to enum value. ">find_enum()</a></li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum type to convert from, inferred from arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_value</td><td>Enum value to convert from </td></tr>
    <tr><td class="paramname">first_enum</td><td>First enum value to map to, maps to first string </td></tr>
    <tr><td class="paramname">last_enum</td><td>Last enum value to map to, maps to last string &ndash; must be &gt;= <code>first_enum</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String for enum value, null if unknown </dd></dl>

</div>
</div>
<a id="a227114595ab6e05964b9908d7fd361da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227114595ab6e05964b9908d7fd361da">&#9670;&nbsp;</a></span>get_enum_string_remap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevo_1_1_sub_string.html">SubString</a> get_enum_string_remap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> *&#160;</td>
          <td class="paramname"><em>reverse_remap_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>enum_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert enum value to key string from list, with unsorted enum remapped to sorted values. </p>
<ul>
<li>This is the reverse of <a class="el" href="classevo_1_1_sub_string_map_list.html#a359115ad4bcf5ea2da0fd24a11f0c15c" title="Find key string in list and convert to enum value, with unsorted enum remapped to sorted values...">find_enum_remap()</a></li>
<li>See also: <a class="el" href="_enum_conversion.html">Enum Conversion</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Enum type to convert from, inferred from arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse_remap_array</td><td>Pointer to index array for mapping sorted strings to unsorted enum values &ndash; see <a class="el" href="structevo_1_1_sub_string_map_list_1_1_reverse_remap.html" title="Builds a reversed enum value remap array for fast reverse lookups. ">ReverseRemap</a> </td></tr>
    <tr><td class="paramname">enum_value</td><td>Enum value to convert from </td></tr>
    <tr><td class="paramname">first_enum</td><td>First enum value to map to, maps to first string </td></tr>
    <tr><td class="paramname">last_enum</td><td>Last enum value to map to, maps to last string &ndash; must be &gt;= <code>first_enum</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String for enum value, null if unknown </dd></dl>

</div>
</div>
<a id="a5fc3ccc049f9327dc84116f44bde5c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3ccc049f9327dc84116f44bde5c26">&#9670;&nbsp;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether null. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether null </dd></dl>

</div>
</div>
<a id="a9e0a87be0fb461bebd7a8b1a99c071e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0a87be0fb461bebd7a8b1a99c071e0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a> size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of items in map. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of items, 0 if empty </dd></dl>

</div>
</div>
<a id="acfbabfd2890993536117374e68617405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbabfd2890993536117374e68617405">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify strings are in correct order. </p>
<ul>
<li>This loops through and compares all strings to verify ordering<ul>
<li>This takes linear time</li>
</ul>
</li>
<li>Duplicates are not considered valid</li>
<li>Call during initialization or from unit tests</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Whether strings are correctly ordered </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>evo/<a class="el" href="substring_8h_source.html">substring.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 7 2019 17:31:07 for Evo C++ Library v0.5.1 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
