<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Evo C++ Library v0.5: Asynchronous I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evo C++ Library v0.5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Asynchronous I/O </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Evo supports asynchronous I/O for high performance clients and servers:</p>
<ul>
<li><a class="el" href="classevo_1_1_async_client.html" title="Template class for an async I/O client. ">AsyncClient</a></li>
<li><a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a></li>
</ul>
<p>See also: <a class="el" href="Streams.html">I/O Streams &amp; Sockets</a></p>
<p>Evo async client and server classes are under namespace <a class="el" href="namespaceevo_1_1async.html">async</a></p>
<p><em>Alpha: Evo Async I/O classes should be considerd a Work In Progress</em></p>
<dl class="section user"><dt>Dependencies</dt><dd></dd></dl>
<p>Evo async I/O requires libevent 2.0 or newer:</p><ul>
<li>Linux/Unix/Cygwin: Link with <code>-levent_core</code> or <code>-levent</code><ul>
<li>To use libevent in multiple threads <code>#</code><code>define EVO_ASYNC_MULTI_THREAD 1</code> (before evo includes) and also link with <code>-levent_pthreads</code> &ndash; <em>otherwise libevent is not thread safe, even with separate instances</em></li>
</ul>
</li>
<li>Windows/MSVC: Link with <code>libevent_core.lib</code> in project configuration:<ul>
<li><code>Configuration -&gt; VC++ Directories -&gt; Include Directories</code></li>
<li><code>Configuration -&gt; VC++ Directories -&gt; Library Directories</code></li>
<li><code>Configuration -&gt; Linker -&gt; Input -&gt; Additional Dependencies</code></li>
<li>To use libevent in multiple threads <code>#</code><code>define EVO_ASYNC_MULTI_THREAD 1</code> (before evo includes) &ndash; <em>otherwise libevent is not thread safe, even with separate instances</em></li>
</ul>
</li>
</ul>
<p>Near the beginning of a program using sockets, call <a class="el" href="classevo_1_1_socket.html#afdae731e3b85dd6cfa9bf1db74de663d" title="Initialize socket library. ">Socket::sysinit()</a> for best portability (required in Windows).</p>
<dl class="section user"><dt>Supported Protocols</dt><dd></dd></dl>
<p>Evo async I/O is designed to support clients and servers using different protocol implementations.</p>
<ul>
<li>Memcached: <a class="el" href="classevo_1_1async_1_1_memcached_client.html">MemcachedClient</a>, <a class="el" href="structevo_1_1async_1_1_memcached_server.html">MemcachedServer</a></li>
<li>Comming soon: Redis, HTTP</li>
</ul>
<dl class="section user"><dt>Client</dt><dd></dd></dl>
<p>The async client classes are named <code>ProtocolClient</code>, where <code>Protocol</code> is the protocol used.</p><ul>
<li>Create a <code>ProtocolClient</code> instance, and setup methods as needed:<ul>
<li>Call <a class="el" href="classevo_1_1_async_base.html#a3125fd474431b01952bb4792723d7b92">client.set_timeout()</a> to set socket timeouts (optional but recommended)</li>
<li>Call <a class="el" href="classevo_1_1_async_base.html#a64794c7bdc8d723b8740db22062fcbf7">client.set_logger()</a> to enable logging</li>
</ul>
</li>
<li>Call a connect method like <a class="el" href="classevo_1_1_async_client.html#ac8b7fffa8bb632f1e8806e14b93155c1">connect_ip()</a> &ndash; this starts a new connection and returns immediately (non-blocking)</li>
<li>Call client methods to make requests (methods are protocol specific) &ndash; the requests are queued while the client is connecting (non-blocking)</li>
<li>An event-loop is required to handle async events with one of the following approaches (examples are below):<ul>
<li><b>Blocking:</b> Call <a class="el" href="classevo_1_1_async_base.html#a311b0ae25c2053fcb91ed7275b6942b4">client.runlocal()</a> to run a local event-loop in the current thread. This blocks until all queued requests are processed and receive responses.<ul>
<li>Multiple clients can share the same event-loop, call <a class="el" href="classevo_1_1_async_client.html#ad4c955c223cdee5b924e6a1066ab13cf">client.attach_to()</a> to attach client to another client-event loop<ul>
<li>When attached, only the root client (the one all others attached to) can run an event-loop</li>
</ul>
</li>
<li>This is useful for pipelining multiple requests then waiting for them to finish, and doing this with multiple clients allows some concurrency (in a single thread)</li>
<li>Not thread safe &ndash; Only one thread may call this at a time</li>
</ul>
</li>
<li><b>Non-blocking</b> <b>Background</b> <b>Thread</b>: <em>Not yet implemented</em></li>
<li><b>Non-blocking</b> <b>Server</b> <b>Back-end</b>: Call <a class="el" href="classevo_1_1_async_client.html#ad4c955c223cdee5b924e6a1066ab13cf">client.attach_to()</a> to attach client to a server event-loop<ul>
<li>This is done when a server is using the client to call another server &ndash; one or more clients can share the server event-loop</li>
<li>Not to share between threads &ndash; Only safe to use from server callbacks or other clients using the same event-loop, i.e. the same server thread</li>
<li>Works with multi-threaded server, as long as each server thread has it's own separate back-end client</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Client callback types:</p><ul>
<li><a class="el" href="structevo_1_1_async_client_1_1_on_connect.html">OnConnect</a></li>
<li><a class="el" href="structevo_1_1_async_client_1_1_on_error.html">OnError</a></li>
<li>Some clients may provide <code>OnEvent</code>, which combines multiple events</li>
<li>Other callbacks depend on the <code>Protocol</code></li>
</ul>
<p>Here's an example using <a class="el" href="classevo_1_1async_1_1_memcached_client.html">MemcachedClient</a> (Memcached protocol):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memcached__client_8h.html">evo/async/memcached_client.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">evo/io.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>OnEvent : <a class="code" href="structevo_1_1async_1_1_memcached_client_1_1_on_event.html">async::MemcachedClient::OnEvent</a> {</div><div class="line">    <span class="keywordtype">void</span> on_connect() {</div><div class="line">        <a class="code" href="group___evo_i_o.html#ga9652bb34b10cb7b6b47c3bb17a0aa008">con</a>().<a class="code" href="structevo_1_1_console.html#aa3d970bba266de23123819eee184108b">out</a> &lt;&lt; <span class="stringliteral">&quot;on_connect()&quot;</span> &lt;&lt; <a class="code" href="namespaceevo.html#aaad808a54ff380fa951955d233d8c3f7">NL</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_store(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, Memcached::StoreResult result) {</div><div class="line">        <a class="code" href="group___evo_i_o.html#ga9652bb34b10cb7b6b47c3bb17a0aa008">con</a>().<a class="code" href="structevo_1_1_console.html#aa3d970bba266de23123819eee184108b">out</a> &lt;&lt; <span class="stringliteral">&quot;on_store() &quot;</span> &lt;&lt; key &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; Memcached::StoreResultEnum::get_string(result) &lt;&lt; <a class="code" href="namespaceevo.html#aaad808a54ff380fa951955d233d8c3f7">NL</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> on_get(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; value, uint32 flags) {</div><div class="line">        <a class="code" href="group___evo_i_o.html#ga9652bb34b10cb7b6b47c3bb17a0aa008">con</a>().<a class="code" href="structevo_1_1_console.html#aa3d970bba266de23123819eee184108b">out</a> &lt;&lt; <span class="stringliteral">&quot;on_get() &quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; &#39;&quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot;&#39; &quot;</span> &lt;&lt; flags &lt;&lt; <a class="code" href="namespaceevo.html#aaad808a54ff380fa951955d233d8c3f7">NL</a>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classevo_1_1_socket.html#afdae731e3b85dd6cfa9bf1db74de663d">Socket::sysinit</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ushort MEMC_PORT = 11211;</div><div class="line">    OnEvent on_event;</div><div class="line"></div><div class="line">    <a class="code" href="classevo_1_1async_1_1_memcached_client.html">async::MemcachedClient</a> memc;</div><div class="line">    memc.<a class="code" href="classevo_1_1_async_client.html#aad31bcc2aae6b17c1a21846e807f2498">set_on_connect</a>(&amp;on_event);</div><div class="line">    memc.<a class="code" href="classevo_1_1_async_client.html#ac8b7fffa8bb632f1e8806e14b93155c1">connect_ip</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, MEMC_PORT);</div><div class="line"></div><div class="line">    memc.<a class="code" href="classevo_1_1async_1_1_memcached_client.html#a2d8db8202e4ca54852096551f204861c">set</a>(<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>, on_event);</div><div class="line">    memc.<a class="code" href="classevo_1_1async_1_1_memcached_client.html#a2d8db8202e4ca54852096551f204861c">set</a>(<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>, on_event);</div><div class="line">    memc.<a class="code" href="classevo_1_1_async_base.html#a311b0ae25c2053fcb91ed7275b6942b4">runlocal</a>();</div><div class="line"></div><div class="line">    memc.<a class="code" href="classevo_1_1async_1_1_memcached_client.html#a001953f6d018c8a81253dfa221ca83cd">get</a>(<span class="stringliteral">&quot;key1&quot;</span>, on_event);</div><div class="line">    memc.<a class="code" href="classevo_1_1async_1_1_memcached_client.html#a001953f6d018c8a81253dfa221ca83cd">get</a>(<span class="stringliteral">&quot;key2&quot;</span>, on_event);</div><div class="line">    memc.<a class="code" href="classevo_1_1_async_base.html#a311b0ae25c2053fcb91ed7275b6942b4">runlocal</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Server</dt><dd></dd></dl>
<p>An async server class is created using a template class implementing a <code>PROTOCOL</code> and passing it a user-defined <code>HANDLER</code> class that implements the protocol event callbacks.</p><ul>
<li>You implement a <code>HANDLER</code> class with the event (callback) methods expected by the <code>PROTOCOL</code><ul>
<li><code>HANDLER</code> is usually a <code>struct</code> (public members) and must:<ul>
<li>inherit <code>ProtocolServerHandler</code> (where <code>Protocol</code> is the <code>PROTOCOL</code> name), which itself inherits <a class="el" href="structevo_1_1_async_server_handler.html" title="Base async I/O server handler. ">AsyncServerHandler</a></li>
<li>optionally define nested struct types: <code>Global</code> and/or <code>Shared</code> &ndash; if not defined then defaults from <a class="el" href="structevo_1_1_async_server_handler.html" title="Base async I/O server handler. ">AsyncServerHandler</a> are used:<ul>
<li><code>Global</code> normally stores configuration info that is read-only from requests, and is shared by all requests and all server threads<ul>
<li>This must be thread safe if server is multi-threaded (optional if single-threaded) &ndash; read-only objects usually are thread-safe</li>
<li>Any writable objects here should be lock-free &ndash; any blocking (mutex locks, synchronous I/O, sleep, etc) should be avoided since the server is asynchronous</li>
<li>Note that if you define <code>Global</code> then you must also define <code>Shared</code> since it references <code>Global</code> (see below)</li>
<li>See <a class="el" href="classevo_1_1_async_server.html#a96f8c4896315eea05f7114c6c789321d" title="Get reference to global data used by all requests and all threads in this server. ...">AsyncServer::get_global()</a> to access this from outside the handler code</li>
</ul>
</li>
<li><code>Shared</code> stores state and back-end client connections, and is shared by all requests in the same thread<ul>
<li>This does not need to be thread safe since it's not shared between threads</li>
<li>This is the place to put back-end clients used by request handlers (which must also be asynchronous)</li>
<li>Required methods:<ul>
<li><code>bool on_init(AsyncBase&amp;, Global&amp;)</code> &ndash; called during startup before first connection is accepted<ul>
<li>Initialize back-end clients here &ndash; they can be attached to the server event-loop here &ndash; see examples below</li>
</ul>
</li>
<li><code>void on_uninit()</code> &ndash; called on shutdown after last connection is handled</li>
</ul>
</li>
<li>For simple cases this can inherit <a class="el" href="structevo_1_1_async_server_handler_1_1_simple_shared_base.html">SimpleSharedBase</a> for a default implementation &ndash; must pass <code>Global</code> type via template argument</li>
<li>Note that this is not accessible from outside the handler code</li>
<li>See also methods in <a class="el" href="structevo_1_1_async_server_handler_1_1_shared.html" title="Default shared data (empty) using default global data type. ">AsyncServerHandler::Shared</a></li>
</ul>
</li>
</ul>
</li>
<li>define a constructor that accepts <code>Global</code> and <code>Shared</code> references and stores them for request handler access, like this: <div class="fragment"><div class="line">Global&amp; global;     <span class="comment">// holds global data -- must be thread safe if server is multi-threaded</span></div><div class="line">Shared&amp; shared;     <span class="comment">// holds shared data</span></div><div class="line"></div><div class="line">HANDLER(Global&amp; global, Shared&amp; shared) : global(global), shared(shared) {</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Note that you only need to store references you will actually use, so you can ignore any of these arguments if desired (but still must accept them)</li>
</ul>
</li>
</ul>
</li>
<li>The server creates a <code>HANDLER</code> instance for each connection, and destroys it when the connection closes</li>
</ul>
</li>
<li>Next, define a server type to use (via typedef) by combining <code>Protocol</code> and <code>HANDLER</code> using: <code>ProtocolServer&lt;HANDLER&gt;::Server</code> (where <code>Protocol</code> is the protocol name)<ul>
<li>The above is a shortcut, the full definition looks like this: <code><a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a>&lt; ProtocolServer&lt;HANDLER&gt; &gt;</code> (where <code>Protocol</code> is the protocol name)</li>
</ul>
</li>
<li>Create a listener <a class="el" href="classevo_1_1_socket.html" title="Socket I/O stream. ">Socket</a> to use with the server</li>
<li>Instantiate the <code>server</code> and then:<ul>
<li>Call <a class="el" href="classevo_1_1_async_server.html#a96f8c4896315eea05f7114c6c789321d">server.get_global()</a> and populate configuration info and state, as required</li>
<li>Call <a class="el" href="classevo_1_1_async_base.html#a3125fd474431b01952bb4792723d7b92">server.set_timeout()</a> to set connection timeouts (optional but recommended)</li>
<li>Call <a class="el" href="classevo_1_1_async_base.html#a64794c7bdc8d723b8740db22062fcbf7">server.set_logger()</a> to enable logging</li>
<li>Call <a class="el" href="classevo_1_1_async_server.html#a09f1a11c7d912814f8aa728e6a06c20a">server.run()</a> to run the server event-loop and handle connections &ndash; this won't return until the server is shut down</li>
<li>A handler or another thread may call <a class="el" href="classevo_1_1_async_server.html#a7861ee1569802186a619778efc85af13">server.shutdown()</a> to stop the server, causing the <code>server.run*()</code> event-loop method used to return</li>
</ul>
</li>
<li>Note that <code>Shared::on_init()</code> is the place to start back-end connections</li>
</ul>
<div align="center">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<map name="dot_inline_dotgraph_3.map" id="dot_inline_dotgraph_3.map"><area shape="rect" id="node1" href="classevo_1_1_async_server.html" title="AsyncServer\&lt;T\&gt;" alt="" coords="41,36,171,85"/>
<area shape="rect" id="node5" href="structevo_1_1_async_server_handler.html" title="\N" alt="" coords="30,457,182,507"/>
</map>
</div>
<center><em>Note: Dashed line shows template parameter type used for member variable, solid line shows inheritance</em></center><p>Here's an example using Memcached <code>PROTOCOL</code> to create a simple async single-threaded memcached server: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memcached__server_8h.html">evo/async/memcached_server.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maphash_8h.html">evo/maphash.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="comment">// Define a Handler type to handle memcached server request events</span></div><div class="line"><span class="keyword">struct </span>Handler : <a class="code" href="structevo_1_1async_1_1_memcached_server_handler_base.html">async::MemcachedServerHandlerBase</a> {</div><div class="line">    <span class="keyword">struct </span>Shared : SimpleSharedBase&lt;&gt; {</div><div class="line">        <a class="code" href="classevo_1_1_map_hash.html">StrHash</a> map;</div><div class="line">    };</div><div class="line"></div><div class="line">    Shared&amp; shared;</div><div class="line"></div><div class="line">    Handler(Global&amp; global, Shared&amp; shared) : shared(shared) {</div><div class="line">    }</div><div class="line"></div><div class="line">    StoreResult on_store(StoreParams&amp; params, <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; value, Command command, uint64 cas_id) {</div><div class="line">        <span class="keywordflow">switch</span>(command) {</div><div class="line">            <span class="keywordflow">case</span> cSET:</div><div class="line">                shared.map[params.key] = value;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                send_error(<span class="stringliteral">&quot;Not supported&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> rtHANDLED;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> Memcached::srSTORED;</div><div class="line">    }</div><div class="line"></div><div class="line">    ResponseType on_get(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, GetAdvParams* adv_params) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classevo_1_1_string.html">String</a>* val = shared.map.find(key);</div><div class="line">        <span class="keywordflow">if</span> (val != NULL)</div><div class="line">            send_value(key, *val);</div><div class="line">        <span class="keywordflow">return</span> rtHANDLED;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Create Memcached Server class using Handler</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classevo_1_1_async_server.html">async::MemcachedServer&lt;Handler&gt;::Server</a> Server;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classevo_1_1_socket.html#afdae731e3b85dd6cfa9bf1db74de663d">Socket::sysinit</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ushort PORT = 11211;</div><div class="line">    <span class="keyword">const</span> ulong RD_TIMEOUT_MS = 5000;</div><div class="line">    <span class="keyword">const</span> ulong WR_TIMEOUT_MS = 1000;</div><div class="line"></div><div class="line">    <a class="code" href="classevo_1_1_socket.html">Socket</a> listener;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        listener.<a class="code" href="classevo_1_1_socket.html#a46f1b0a8fe0182aef3c701510c6c1fc0">listen_ip</a>(PORT);</div><div class="line">    } <a class="code" href="io_8h.html#a62795ba73c4ad6bca92f96bd5a3c59cc">EVO_CATCH</a>(<span class="keywordflow">return</span> 1)</div><div class="line"></div><div class="line">    Server server;</div><div class="line">    server.set_timeout(RD_TIMEOUT_MS, WR_TIMEOUT_MS);</div><div class="line">    server.run(listener);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Server - Deferred Response</dt><dd></dd></dl>
<p>If a server handler has to wait on something to get a response, this is called a <em>Deferred Response</em>.</p>
<ul>
<li>The server handler must not block so it creates a <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t_1_1_reply_base.html">ProtocolServer::DeferredReply</a> and returns <code>rtDEFERRED</code> indicating the response will be sent later<ul>
<li>Only one <code>DeferredReply</code> is allowed per handler event &ndash; for complex event chains you'll need to keep state in the event object and send the response at the end</li>
</ul>
</li>
<li>An instance of <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t_1_1_reply_base.html">ProtocolServer::DeferredReply</a> is created to send this deferred reply, and is inherited by or associated with an external event object</li>
<li>When the wait is over, one of the <code>DeferredReply::deferred_reply_*()</code> methods must be called to send a response, then the <code>DeferredReply</code> should be destroyed</li>
<li>Example use case: A request requires a back-end server call to send a response (like a proxy server):<ul>
<li>Example chain of events:<ul>
<li>Server: Receive request 1<ul>
<li>Client: Send back-end request for request 1</li>
</ul>
</li>
<li>Client: Back-end response for request 1 (or client error occurred)<ul>
<li>Server: Send response for request 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Deferred responses on the same connection may be "out of order", which the framework handles with a queue so responses are always sent in the right order (matching request order)<ul>
<li>Simple example:<ul>
<li>Response 1: Deferred</li>
<li>Response 2: Not deferred, sent but queued until response 1 is sent first</li>
<li>Response 1: Sent, and response 2 from queue is then sent too</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Examples when deferred response is required:</p><ul>
<li>Proxy or mid-tier server calling another back-end server (as mentioned above)</li>
<li>Processing in another thread, which may be expensive or use blocking I/O</li>
</ul>
<p>Here's a more complex example using Memcached <code>PROTOCOL</code> to create a simple async single-threaded memcached proxy server that uses a client to call a back-end memcached server: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memcached_8h.html">evo/async/memcached.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="comment">// Define a Handler type to handle memcached server request events</span></div><div class="line"><span class="keyword">struct </span>ServerHandler : <span class="keyword">public</span> <a class="code" href="structevo_1_1async_1_1_memcached_server_handler_base.html">async::MemcachedServerHandlerBase</a> {</div><div class="line">    <span class="comment">// Global configuration for all requests</span></div><div class="line">    <span class="keyword">struct </span>Global {</div><div class="line">        <a class="code" href="classevo_1_1_string.html">String</a> proxy_address;</div><div class="line">        ushort proxy_port;</div><div class="line"></div><div class="line">        Global() : proxy_port(0) {</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Shared state per thread</span></div><div class="line">    <span class="keyword">struct </span>Shared {</div><div class="line">        <a class="code" href="classevo_1_1async_1_1_memcached_client.html">async::MemcachedClient</a> client;  <span class="comment">// client for calling back-end server</span></div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> on_init(<a class="code" href="classevo_1_1_async_base.html">AsyncBase</a>&amp; server, Global&amp; global) {</div><div class="line">            <a class="code" href="classevo_1_1_string.html">String</a> tmp;</div><div class="line">            client.<a class="code" href="classevo_1_1_async_client.html#ad4c955c223cdee5b924e6a1066ab13cf">attach_to</a>(server); <span class="comment">// attach client to server event-loop</span></div><div class="line">            <span class="keywordflow">if</span> (!client.<a class="code" href="classevo_1_1_async_client.html#ac8b7fffa8bb632f1e8806e14b93155c1">connect_ip</a>(global.proxy_address.cstr(tmp), global.proxy_port))</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Used to make a back-end request via client -- this either gets a response or an error occurs</span></div><div class="line">    <span class="comment">// - After the response (or error) this deletes itself to cleanup</span></div><div class="line">    <span class="keyword">struct </span>OnClientEvent : DeferredReply, <a class="code" href="structevo_1_1async_1_1_memcached_client_1_1_on_event.html">async::MemcachedClient::OnEvent</a>, async::MemcachedClient::OnError {</div><div class="line">        OnClientEvent(ServerHandler&amp; parent, ulong <span class="keywordtype">id</span>) : DeferredReply(parent, id) {</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> on_store(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, Memcached::StoreResult result) {</div><div class="line">            deferred_reply_store(result);</div><div class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>; <span class="comment">// deferred response complete, delete callback</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> on_get(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; value, uint32 flags) {</div><div class="line">            deferred_reply_get(key, value, flags);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> on_get_end(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp;) {</div><div class="line">            deferred_reply_get_end();</div><div class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>; <span class="comment">// deferred response complete, delete callback</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> on_error(<a class="code" href="group___evo_i_o.html#gaa9de21c87ab89aacb9da9dba6b240114">AsyncError</a> error) {</div><div class="line">            deferred_reply_error(<span class="stringliteral">&quot;Backend client error&quot;</span>);</div><div class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>; <span class="comment">// deferred response aborted on error, delete callback</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    Global&amp; global;</div><div class="line">    Shared&amp; shared;</div><div class="line"></div><div class="line">    ServerHandler(Global&amp; global, Shared&amp; shared) : global(global), shared(shared) {</div><div class="line">    }</div><div class="line"></div><div class="line">    StoreResult on_store(StoreParams&amp; params, <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; value, Command command, uint64 cas_id) {</div><div class="line">        <span class="keywordflow">if</span> (noreply) {</div><div class="line">            <span class="comment">// Call back-end via client, no reply expected</span></div><div class="line">            shared.client.set(params.key, value, params.flags, params.expire);</div><div class="line">            <span class="keywordflow">return</span> Memcached::srSTORED;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <span class="comment">// Call back-end via client, response is deferred until client gets response (or an error occurs)</span></div><div class="line">            OnClientEvent* on_event = <span class="keyword">new</span> OnClientEvent(*<span class="keyword">this</span>, <span class="keywordtype">id</span>);</div><div class="line">            <span class="keywordflow">if</span> (!shared.client.set(params.key, value, params.flags, params.expire, NULL, on_event, on_event)) {</div><div class="line">                <span class="keyword">delete</span> on_event;</div><div class="line">                send_error(<span class="stringliteral">&quot;Error calling back-end&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> rtHANDLED; <span class="comment">// error sent, not deferred</span></div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> rtDEFERRED;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ResponseType on_get(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">SubString</a>&amp; key, GetAdvParams* adv_params) {</div><div class="line">        <span class="comment">// Call back-end via client, response is deferred until client gets response (or an error occurs)</span></div><div class="line">        OnClientEvent* on_event = <span class="keyword">new</span> OnClientEvent(*<span class="keyword">this</span>, <span class="keywordtype">id</span>);</div><div class="line">        <span class="keywordflow">if</span> (!shared.client.get(key, *on_event, on_event)) {</div><div class="line">            <span class="keyword">delete</span> on_event;</div><div class="line">            send_error(<span class="stringliteral">&quot;Error calling back-end&quot;</span>);</div><div class="line">            <span class="keywordflow">return</span> rtHANDLED;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> rtDEFERRED;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Create Memcached Server class using ServerHandler</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classevo_1_1_async_server.html">async::MemcachedServer&lt;ServerHandler&gt;::Server</a> Server;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classevo_1_1_socket.html#afdae731e3b85dd6cfa9bf1db74de663d">Socket::sysinit</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ushort PORT = 11210;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classevo_1_1_string.html">String</a> BACKEND_ADDRESS = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div><div class="line">    <span class="keyword">const</span> ushort BACKEND_PORT = 11211;</div><div class="line">    <span class="keyword">const</span> ulong RD_TIMEOUT_MS = 5000;</div><div class="line">    <span class="keyword">const</span> ulong WR_TIMEOUT_MS = 1000;</div><div class="line"></div><div class="line">    <a class="code" href="classevo_1_1_socket.html">Socket</a> listener;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        listener.<a class="code" href="classevo_1_1_socket.html#a46f1b0a8fe0182aef3c701510c6c1fc0">listen_ip</a>(PORT);</div><div class="line">    } <a class="code" href="io_8h.html#a62795ba73c4ad6bca92f96bd5a3c59cc">EVO_CATCH</a>(<span class="keywordflow">return</span> 1)</div><div class="line"></div><div class="line">    Server server;</div><div class="line">    {</div><div class="line">        Server::Global&amp; global = server.get_global();</div><div class="line">        global.proxy_address = BACKEND_ADDRESS;</div><div class="line">        global.proxy_port = BACKEND_PORT;</div><div class="line">    }</div><div class="line">    server.set_timeout(RD_TIMEOUT_MS, WR_TIMEOUT_MS);</div><div class="line">    server.run(listener);</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>Implementation Detail</dt><dd></dd></dl>
<p><a class="el" href="classevo_1_1_async_client.html" title="Template class for an async I/O client. ">AsyncClient</a> and <a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a> both use an <a class="el" href="classevo_1_1_async_event_loop.html" title="Manages an event-loop for async I/O. ">AsyncEventLoop</a> to wait for I/O and call the appropriate callbacks.</p>
<ul>
<li>A number of <a class="el" href="classevo_1_1_async_client.html" title="Template class for an async I/O client. ">AsyncClient</a> objects can "attach" to an <a class="el" href="classevo_1_1_async_server.html" title="Async I/O server for receiving and handling requests. ">AsyncServer</a> to share the same event-loop</li>
<li>The event-loop itself uses a low-level API (libevent) to wait for I/O and trigger low-level callbacks, which call the appropriate higher-level callbacks</li>
</ul>
<div align="center">
<img src="dot_inline_dotgraph_4.png" alt="dot_inline_dotgraph_4.png" border="0" usemap="#dot_inline_dotgraph_4.map"/>
<map name="dot_inline_dotgraph_4.map" id="dot_inline_dotgraph_4.map"><area shape="rect" id="node1" href="classevo_1_1_async_client.html" title="\N" alt="" coords="5,36,101,85"/>
<area shape="rect" id="node3" href="classevo_1_1_async_base.html" title="\N" alt="" coords="69,135,161,184"/>
<area shape="rect" id="node2" href="classevo_1_1_async_server.html" title="\N" alt="" coords="126,36,229,85"/>
<area shape="rect" id="node4" href="classevo_1_1_async_event_loop.html" title="\N" alt="" coords="51,247,178,296"/>
</map>
</div>
<dl class="section user"><dt>Implementation Detail - Client</dt><dd></dd></dl>
<p>Client request internal details:</p><ul>
<li>Sending a request:<ul>
<li>Write request to socket buffer</li>
<li>Add request response info to queue (if reply expected)</li>
</ul>
</li>
<li>On socket read-ready (data received):<ul>
<li>Pop request response info from queue<ul>
<li>If queue is empty this is usually a protocol error and if so close socket (details depend on protocol)</li>
</ul>
</li>
<li>Async wait for more data if needed (continue on next socket read ready)</li>
<li>Read request response from socket buffer<ul>
<li>On error, invoke response info <code>on_error</code> callback (if not null) then close socket</li>
</ul>
</li>
<li>Invoke client callback for response</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Implementation Detail - Server</dt><dd></dd></dl>
<p>When a server accepts an incoming connection:</p><ul>
<li>An internal <code>Connection</code> object is created to represent the client connection, which has:<ul>
<li>a <code>ProtocolServer</code> instance that receives socket events for this connection and implements the protocol layer:<ul>
<li>this has an instance of the server-defined <code>HANDLER</code> which implements the protocol events and sends responses back to the connected client</li>
<li>the <code>HANDLER</code> has an instance of <a class="el" href="classevo_1_1_async_server_reply_t.html">AsyncServerReply</a> (via inheritance)</li>
</ul>
</li>
<li>a <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t.html">HANDLER::DeferredContext</a> instance for sending deferred responses<ul>
<li>this has a pending deferred response reference count and a pointer to the server-defined <code>HANDLER</code> for sending deferred responses, which is set to <code>NULL</code> when the connection is closed</li>
<li>this is destroyed when the connection is closed and when no more deferred responses are in progress</li>
<li>more on deferred responses below</li>
</ul>
</li>
<li>a <code>HANDLER</code> instance with event implementations, which has an <a class="el" href="group___evo_i_o.html#ga12c8bf593100edd98ce354feaa93723e">AsyncServerReply</a> instance (via inheritance) for sending responses<ul>
<li>a <code>HANDLER</code> event creates a <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t_1_1_reply_base.html">HANDLER::DeferredReply</a> to make a deferred response (more on this below)</li>
</ul>
</li>
</ul>
</li>
<li>The <code>Connection</code> object is destroyed when the connection closes</li>
</ul>
<div align="center">
<img src="dot_inline_dotgraph_5.png" alt="dot_inline_dotgraph_5.png" border="0" usemap="#dot_inline_dotgraph_5.map"/>
<map name="dot_inline_dotgraph_5.map" id="dot_inline_dotgraph_5.map"><area shape="rect" id="node1" href="classevo_1_1_async_server.html" title="\N" alt="" coords="91,36,194,85"/>
<area shape="rect" id="node3" href="structevo_1_1_async_server_handler_1_1_deferred_context_t.html" title="\N" alt="" coords="5,260,133,309"/>
<area shape="rect" id="node6" href="classevo_1_1_async_server_reply_t.html" title="\N" alt="" coords="14,484,125,533"/>
<area shape="rect" id="node7" href="classevo_1_1_async_server_reply_t.html" title="\N" alt="" coords="149,484,283,533"/>
</map>
</div>
<p>Response types:</p><ul>
<li>Normal responses are sent immediately by the <code>HANDLER</code> (details depend on the protocol)</li>
<li>Deferred responses are more complex (see diagram below) and are required when the server must wait for a response (without blocking):<ul>
<li>The <code>HANDLER</code> creates a <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t_1_1_reply_base.html">HANDLER::DeferredReply</a> event/object, starts an async (non-blocking) operation, then returns <code>rtDEFERRED</code> result</li>
<li>The server handles other requests and events while the deferred response is in progress</li>
<li>When a response is ready, an async callback uses the <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t_1_1_reply_base.html">HANDLER::DeferredReply</a> object to send the response</li>
</ul>
</li>
</ul>
<center><b>Deferred Response</b></center> <div align="center">
<img src="msc_inline_mscgraph_1.png" alt="msc_inline_mscgraph_1" border="0" usemap="#msc_inline_mscgraph_1.map"/>
<map name="msc_inline_mscgraph_1.map" id="msc_inline_mscgraph_1.map"></map>
</div>
<p>The framework handles these scenarios with deferred responses:</p><ul>
<li>Out of order response: Async events don't have a predictable order so responses may happen out of order<ul>
<li>The framework accounts for this by sending responses through <a class="el" href="group___evo_i_o.html#ga12c8bf593100edd98ce354feaa93723e">AsyncServerReply</a>, which queues responses when they're out of order</li>
<li>Ordering is corrected for any mixture of deferred and non-deferred responses, so the response order always matches the request order</li>
</ul>
</li>
<li>Connection closed unexpectedly while deferred responses are pending:<ul>
<li>The framework handles this using <a class="el" href="structevo_1_1_async_server_handler_1_1_deferred_context_t.html">DeferredContext</a>, which is detached from the <code>Connection</code> when closed and a deferred response is pending</li>
<li>When the connection is closed the deferred responses for it become no-ops, but still must be cleaned up</li>
<li>After all pending deferred responses are complete the <code>DeferredContext</code> is destroyed </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2019 22:50:50 for Evo C++ Library v0.5 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
