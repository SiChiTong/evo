<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Evo C++ Library v0.5: EvoContainers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evo C++ Library v0.5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">EvoContainers</div>  </div>
</div><!--header-->
<div class="contents">

<p>Evo containers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_array.html">Array&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array container with similar interface to <a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a>.  <a href="classevo_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_atomic_buffer_queue.html">AtomicBufferQueue&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast buffer-based queue, implemented with a ring-buffer.  <a href="classevo_1_1_atomic_buffer_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_bit_array_subset_t.html">BitArraySubsetT&lt; TParent &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subset of a BitArray.  <a href="classevo_1_1_bit_array_subset_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_bit_array_t.html">BitArrayT&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic bit array container with similar interface to <a class="el" href="classevo_1_1_array.html" title="Dynamic array container with similar interface to List. ">Array</a> and <a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a>.  <a href="classevo_1_1_bit_array_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_buffer_queue.html">BufferQueue&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast buffer-based queue, implemented with a ring-buffer.  <a href="classevo_1_1_buffer_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_capacity.html">Capacity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized container size and capacity calculation.  <a href="classevo_1_1_capacity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare.html">Compare&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison object used with containers that order/sort items.  <a href="structevo_1_1_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare_base.html">CompareBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for comparison types.  <a href="structevo_1_1_compare_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare_hash.html">CompareHash&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash object used with containers that hash items.  <a href="structevo_1_1_compare_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare_i.html">CompareI&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison object used with containers that order/sort items (case-insensitive).  <a href="structevo_1_1_compare_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare_i_r.html">CompareIR&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison object used with containers that order/sort items (case-insensitive, reverse).  <a href="structevo_1_1_compare_i_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_compare_r.html">CompareR&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison object used with containers that order/sort items (reverse).  <a href="structevo_1_1_compare_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_compare.html">DataCompare&lt; T, B1, B2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data comparison helpers.  <a href="structevo_1_1_data_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_copy.html">DataCopy&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized data copy helpers.  <a href="structevo_1_1_data_copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_equal.html">DataEqual&lt; T, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data equality helper.  <a href="structevo_1_1_data_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_fill.html">DataFill&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized data fill helpers.  <a href="structevo_1_1_data_fill.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_hash.html">DataHash&lt; T, H, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized data hash helpers.  <a href="structevo_1_1_data_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_init.html">DataInit&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized data initialization and uninitialization helpers.  <a href="structevo_1_1_data_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_data_type.html">DataType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base data type for optimizated data helpers.  <a href="structevo_1_1_data_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_enum_iterator.html">EnumIterator&lt; T, F, L &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator template for sequential enum values.  <a href="classevo_1_1_enum_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_enum_map_iterator.html">EnumMapIterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expanded <a class="el" href="classevo_1_1_enum_iterator.html" title="Iterator template for sequential enum values. ">EnumIterator</a> used with enum traits.  <a href="structevo_1_1_enum_map_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_exception_sub_string_map_list.html">ExceptionSubStringMapList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_sub_string_map_list.html" title="References a list of sorted substrings for fast lookup. ">SubStringMapList</a> input ordering verification failed, see <a class="el" href="classevo_1_1_exception.html" title="Evo base exception class. ">Exception</a>.  <a href="classevo_1_1_exception_sub_string_map_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_attribs.html">FmtAttribs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting attributes (used internally).  <a href="structevo_1_1_fmt_attribs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_char.html">FmtChar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a repeated character.  <a href="structevo_1_1_fmt_char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_dump.html">FmtDump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a hex dump from buffer.  <a href="structevo_1_1_fmt_dump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_float_t.html">FmtFloatT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a floating pointer number.  <a href="structevo_1_1_fmt_float_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_int_t.html">FmtIntT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="structevo_1_1_fmt_int_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_ptr.html">FmtPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a pointer.  <a href="structevo_1_1_fmt_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_set_field.html">FmtSetField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds field and alignment formatting attributes.  <a href="structevo_1_1_fmt_set_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_set_float.html">FmtSetFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds floating point formatting attributes.  <a href="structevo_1_1_fmt_set_float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_set_int.html">FmtSetInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds integer formatting attributes.  <a href="structevo_1_1_fmt_set_int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_set_null.html">FmtSetNull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds string to use when formatting null values.  <a href="structevo_1_1_fmt_set_null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_string.html">FmtString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a string.  <a href="structevo_1_1_fmt_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_fmt_string_wrap.html">FmtStringWrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_iterator_base.html">IteratorBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base iterator (used internally).  <a href="classevo_1_1_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_iterator_bi.html">IteratorBi&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional iterator.  <a href="classevo_1_1_iterator_bi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_iterator_fw.html">IteratorFw&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classevo_1_1_iterator_fw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_iterator_ra.html">IteratorRa&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator.  <a href="classevo_1_1_iterator_ra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_list.html">List&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential list container with random access.  <a href="classevo_1_1_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_map.html">Map&lt; TKey, TValue, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container holding key/value pairs for fast lookup.  <a href="classevo_1_1_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_map_hash.html">MapHash&lt; TKey, TValue, THash, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_map.html" title="Associative container holding key/value pairs for fast lookup. ">Map</a> implemented as a hash table.  <a href="classevo_1_1_map_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_map_list.html">MapList&lt; TKey, TValue, TCompare, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_map.html" title="Associative container holding key/value pairs for fast lookup. ">Map</a> implemented as an ordered list.  <a href="classevo_1_1_map_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_pair.html">Pair&lt; TA, TB &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a key/value pair of independent objects or values.  <a href="structevo_1_1_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html">PtrList&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential list of managed pointers with random access.  <a href="classevo_1_1_ptr_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_set.html">Set&lt; TKey, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container with unique values for fast lookup.  <a href="classevo_1_1_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_set_hash.html">SetHash&lt; TKey, THash, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> implemented as a hash table.  <a href="classevo_1_1_set_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_set_list.html">SetList&lt; TKey, TCompare, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> implemented as an ordered sequential array/list.  <a href="classevo_1_1_set_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String container.  <a href="classevo_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_string_flt.html">StringFlt&lt; T, PADDING &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String fixed-size buffer for formatting a floating point number.  <a href="structevo_1_1_string_flt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_string_int.html">StringInt&lt; T, PADDING &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String fixed-size buffer for formatting an integer.  <a href="structevo_1_1_string_int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_str_quoting.html">StrQuoting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers for determining quoting type to use with string data.  <a href="structevo_1_1_str_quoting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_sub_list.html">SubList&lt; T, TSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference and access existing list data.  <a href="structevo_1_1_sub_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_sub_string.html">SubString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference and access existing string data.  <a href="structevo_1_1_sub_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_sub_string_map_list.html">SubStringMapList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">References a list of sorted substrings for fast lookup.  <a href="classevo_1_1_sub_string_map_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_unicode_string.html">UnicodeString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unicode string container using UTF-16.  <a href="classevo_1_1_unicode_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose variable that can hold a basic value (string, number, bool, etc) or children with nested values (object, list).  <a href="classevo_1_1_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_var_object.html">VarObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit variant of <a class="el" href="classevo_1_1_var.html" title="General purpose variable that can hold a basic value (string, number, bool, etc) or children with nes...">Var</a> used for initializing as an object with an initializer list of key/value pairs (C++11).  <a href="classevo_1_1_var_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4b7b4d2b7ae0e14ea11353b2a512788f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga4b7b4d2b7ae0e14ea11353b2a512788f">EVO_ENUM_CLASS_MAP</a>(ENUM, ...)</td></tr>
<tr class="memdesc:ga4b7b4d2b7ae0e14ea11353b2a512788f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum class string/value mappers (C++11).  <a href="#ga4b7b4d2b7ae0e14ea11353b2a512788f">More...</a><br /></td></tr>
<tr class="separator:ga4b7b4d2b7ae0e14ea11353b2a512788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad393c06275e73692f0e74d37f38e795b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad393c06275e73692f0e74d37f38e795b">EVO_ENUM_CLASS_REMAP</a>(ENUM,  REMAP_ARRAY, ...)</td></tr>
<tr class="memdesc:gad393c06275e73692f0e74d37f38e795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum class string/value mappers, with unsorted enum remapped to sorted values.  <a href="#gad393c06275e73692f0e74d37f38e795b">More...</a><br /></td></tr>
<tr class="separator:gad393c06275e73692f0e74d37f38e795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e9898e6d31c9187eba0f588e348a5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gab9e9898e6d31c9187eba0f588e348a5d">EVO_ENUM_MAP</a>(ENUM,  FIRST_VAL,  LAST_VAL,  UNKNOWN_VAL, ...)</td></tr>
<tr class="memdesc:gab9e9898e6d31c9187eba0f588e348a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum string/value mappers with explicit first/last/unknown values.  <a href="#gab9e9898e6d31c9187eba0f588e348a5d">More...</a><br /></td></tr>
<tr class="separator:gab9e9898e6d31c9187eba0f588e348a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74dbbe26bf9a19598be4726357e31e81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga74dbbe26bf9a19598be4726357e31e81">EVO_ENUM_MAP_PREFIXED</a>(ENUM,  PREFIX, ...)&#160;&#160;&#160;<a class="el" href="group___evo_containers.html#gab9e9898e6d31c9187eba0f588e348a5d">EVO_ENUM_MAP</a>(ENUM, (ENUM)((int)(PREFIX ## UNKNOWN) + 1), (ENUM)((int)(PREFIX ## ENUM_END) - 1), PREFIX ## UNKNOWN, __VA_ARGS__)</td></tr>
<tr class="memdesc:ga74dbbe26bf9a19598be4726357e31e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum string/value mappers with prefixed enum values.  <a href="#ga74dbbe26bf9a19598be4726357e31e81">More...</a><br /></td></tr>
<tr class="separator:ga74dbbe26bf9a19598be4726357e31e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72fd004c4fe4b7174f95db9a47e3d0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaf72fd004c4fe4b7174f95db9a47e3d0f">EVO_ENUM_REMAP</a>(ENUM,  FIRST_VAL,  LAST_VAL,  UNKNOWN_VAL,  REMAP_ARRAY, ...)</td></tr>
<tr class="memdesc:gaf72fd004c4fe4b7174f95db9a47e3d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum string/value mappers with explicit first/last/unknown values, with unsorted enum remapped to sorted values.  <a href="#gaf72fd004c4fe4b7174f95db9a47e3d0f">More...</a><br /></td></tr>
<tr class="separator:gaf72fd004c4fe4b7174f95db9a47e3d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3a83429e05c602ce666b93bf865c1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gace3a83429e05c602ce666b93bf865c1f">EVO_ENUM_REMAP_PREFIXED</a>(ENUM,  PREFIX,  REMAP_ARRAY, ...)&#160;&#160;&#160;<a class="el" href="group___evo_containers.html#gaf72fd004c4fe4b7174f95db9a47e3d0f">EVO_ENUM_REMAP</a>(ENUM, (ENUM)((int)(PREFIX ## UNKNOWN) + 1), (ENUM)((int)(PREFIX ## ENUM_END) - 1), PREFIX ## UNKNOWN, REMAP_ARRAY, __VA_ARGS__)</td></tr>
<tr class="memdesc:gace3a83429e05c602ce666b93bf865c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating enum string/value mappers with prefixed enum values, with unsorted enum remapped to sorted values.  <a href="#gace3a83429e05c602ce666b93bf865c1f">More...</a><br /></td></tr>
<tr class="separator:gace3a83429e05c602ce666b93bf865c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe6bf882e790c50e3f95903729dcaf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gacfe6bf882e790c50e3f95903729dcaf0">EVO_EXCEPTION_GUARD_END</a>&#160;&#160;&#160;} catch (...) { abort(); }</td></tr>
<tr class="memdesc:gacfe6bf882e790c50e3f95903729dcaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End exception guard, catch and abort().  <a href="#gacfe6bf882e790c50e3f95903729dcaf0">More...</a><br /></td></tr>
<tr class="separator:gacfe6bf882e790c50e3f95903729dcaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefb0b1be8356978c929a7500037df949"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaefb0b1be8356978c929a7500037df949">EVO_EXCEPTION_GUARD_START</a>&#160;&#160;&#160;try {</td></tr>
<tr class="memdesc:gaefb0b1be8356978c929a7500037df949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start exception guard (try block).  <a href="#gaefb0b1be8356978c929a7500037df949">More...</a><br /></td></tr>
<tr class="separator:gaefb0b1be8356978c929a7500037df949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga402af8f7443cab5ca15eb9115f7355a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga402af8f7443cab5ca15eb9115f7355a6">EVO_FIXED_ARRAY_SIZE</a>(ARRAY)&#160;&#160;&#160;(sizeof(evo::impl::FixedArraySizeHelper(ARRAY)))</td></tr>
<tr class="memdesc:ga402af8f7443cab5ca15eb9115f7355a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of fixed-length array at compile-time.  <a href="#ga402af8f7443cab5ca15eb9115f7355a6">More...</a><br /></td></tr>
<tr class="separator:ga402af8f7443cab5ca15eb9115f7355a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3a394eec1fb611abb2d9a6d54e65b796"><td class="memItemLeft" align="right" valign="top">typedef BitArrayT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga3a394eec1fb611abb2d9a6d54e65b796">BitArray</a></td></tr>
<tr class="memdesc:ga3a394eec1fb611abb2d9a6d54e65b796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default dynamic bit array container &ndash; see <a class="el" href="classevo_1_1_bit_array_t.html" title="Dynamic bit array container with similar interface to Array and List. ">BitArrayT</a>.  <a href="group___evo_containers.html#ga3a394eec1fb611abb2d9a6d54e65b796">More...</a><br /></td></tr>
<tr class="separator:ga3a394eec1fb611abb2d9a6d54e65b796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad4c6636a2267a687c34cd00a6ab930"><td class="memItemLeft" align="right" valign="top">typedef BitArraySubsetT&lt; BitArray &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga9ad4c6636a2267a687c34cd00a6ab930">BitArraySubset</a></td></tr>
<tr class="memdesc:ga9ad4c6636a2267a687c34cd00a6ab930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default subset of a BitArray &ndash; see <a class="el" href="classevo_1_1_bit_array_subset_t.html" title="A subset of a BitArray. ">BitArraySubsetT</a>.  <a href="group___evo_containers.html#ga9ad4c6636a2267a687c34cd00a6ab930">More...</a><br /></td></tr>
<tr class="separator:ga9ad4c6636a2267a687c34cd00a6ab930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185dac6c097eb183ddce255a5cb5c4c4"><td class="memItemLeft" align="right" valign="top">typedef FmtFloatT&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a></td></tr>
<tr class="memdesc:ga185dac6c097eb183ddce255a5cb5c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a floating pointer number.  <a href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">More...</a><br /></td></tr>
<tr class="separator:ga185dac6c097eb183ddce255a5cb5c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545d13254cd3cc232fbd30dc48d63152"><td class="memItemLeft" align="right" valign="top">typedef FmtFloatT&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga545d13254cd3cc232fbd30dc48d63152">FmtFloatD</a></td></tr>
<tr class="memdesc:ga545d13254cd3cc232fbd30dc48d63152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a floating pointer number.  <a href="group___evo_containers.html#ga545d13254cd3cc232fbd30dc48d63152">More...</a><br /></td></tr>
<tr class="separator:ga545d13254cd3cc232fbd30dc48d63152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5513765313933e17b162b20dee1f1d86"><td class="memItemLeft" align="right" valign="top">typedef FmtFloatT&lt; ldouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga5513765313933e17b162b20dee1f1d86">FmtFloatL</a></td></tr>
<tr class="memdesc:ga5513765313933e17b162b20dee1f1d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format a floating pointer number.  <a href="group___evo_containers.html#ga5513765313933e17b162b20dee1f1d86">More...</a><br /></td></tr>
<tr class="separator:ga5513765313933e17b162b20dee1f1d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11a4171455dc0fc86d7461af86ac5e0"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></td></tr>
<tr class="memdesc:gab11a4171455dc0fc86d7461af86ac5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">More...</a><br /></td></tr>
<tr class="separator:gab11a4171455dc0fc86d7461af86ac5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8964dee24a784fe440b255aad52838f"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; int16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a></td></tr>
<tr class="memdesc:gac8964dee24a784fe440b255aad52838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">More...</a><br /></td></tr>
<tr class="separator:gac8964dee24a784fe440b255aad52838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e57ecfe81770bde63a80428c7a8a62b"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; int32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a></td></tr>
<tr class="memdesc:ga8e57ecfe81770bde63a80428c7a8a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">More...</a><br /></td></tr>
<tr class="separator:ga8e57ecfe81770bde63a80428c7a8a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f59c175d16c2831d019b9030a10b28d"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; int64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></td></tr>
<tr class="memdesc:ga4f59c175d16c2831d019b9030a10b28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">More...</a><br /></td></tr>
<tr class="separator:ga4f59c175d16c2831d019b9030a10b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad317e402a75ccba4dc59204a910f1b37"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; int8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a></td></tr>
<tr class="memdesc:gad317e402a75ccba4dc59204a910f1b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">More...</a><br /></td></tr>
<tr class="separator:gad317e402a75ccba4dc59204a910f1b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955eda15a9868f3f66e8f943d7196a22"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a></td></tr>
<tr class="memdesc:ga955eda15a9868f3f66e8f943d7196a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">More...</a><br /></td></tr>
<tr class="separator:ga955eda15a9868f3f66e8f943d7196a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4e13382160aebe0a0ff2863e28fa9e"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; longl &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></td></tr>
<tr class="memdesc:gabe4e13382160aebe0a0ff2863e28fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">More...</a><br /></td></tr>
<tr class="separator:gabe4e13382160aebe0a0ff2863e28fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcfe9402503bfc12694c9d1aadfb8abc"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a></td></tr>
<tr class="memdesc:gafcfe9402503bfc12694c9d1aadfb8abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">More...</a><br /></td></tr>
<tr class="separator:gafcfe9402503bfc12694c9d1aadfb8abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b19e8b7debda86abc7bb3b6d5a4dad2"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a></td></tr>
<tr class="memdesc:ga7b19e8b7debda86abc7bb3b6d5a4dad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">More...</a><br /></td></tr>
<tr class="separator:ga7b19e8b7debda86abc7bb3b6d5a4dad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35081c859ad442bda2b516bbf293e41"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; uint16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a></td></tr>
<tr class="memdesc:gad35081c859ad442bda2b516bbf293e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">More...</a><br /></td></tr>
<tr class="separator:gad35081c859ad442bda2b516bbf293e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950e58f7503ea2025692eb07016e5326"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a></td></tr>
<tr class="memdesc:ga950e58f7503ea2025692eb07016e5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">More...</a><br /></td></tr>
<tr class="separator:ga950e58f7503ea2025692eb07016e5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fe152e7d1a710deea855ae6bbe53ba"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; uint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></td></tr>
<tr class="memdesc:gad2fe152e7d1a710deea855ae6bbe53ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">More...</a><br /></td></tr>
<tr class="separator:gad2fe152e7d1a710deea855ae6bbe53ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1f98e783ca0b4249bb8495d4f08821"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; uint8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a></td></tr>
<tr class="memdesc:ga1b1f98e783ca0b4249bb8495d4f08821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">More...</a><br /></td></tr>
<tr class="separator:ga1b1f98e783ca0b4249bb8495d4f08821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b966ec807f8a29b516fdcd96c6fdbc"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; ulong &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a></td></tr>
<tr class="memdesc:gad1b966ec807f8a29b516fdcd96c6fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">More...</a><br /></td></tr>
<tr class="separator:gad1b966ec807f8a29b516fdcd96c6fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6556776dad40b74bf17707df78460590"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; ulongl &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></td></tr>
<tr class="memdesc:ga6556776dad40b74bf17707df78460590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">More...</a><br /></td></tr>
<tr class="separator:ga6556776dad40b74bf17707df78460590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c8e4d440603226b6d8b24c45e3d972"><td class="memItemLeft" align="right" valign="top">typedef FmtIntT&lt; ushort &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a></td></tr>
<tr class="memdesc:ga75c8e4d440603226b6d8b24c45e3d972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly format an integer.  <a href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">More...</a><br /></td></tr>
<tr class="separator:ga75c8e4d440603226b6d8b24c45e3d972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5951ce48779180c0473baae410bc80c4"><td class="memItemLeft" align="right" valign="top">typedef MapHash&lt; String, String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga5951ce48779180c0473baae410bc80c4">StrHash</a></td></tr>
<tr class="memdesc:ga5951ce48779180c0473baae410bc80c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_map_hash.html" title="Map implemented as a hash table. ">MapHash</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> keys and values.  <a href="group___evo_containers.html#ga5951ce48779180c0473baae410bc80c4">More...</a><br /></td></tr>
<tr class="separator:ga5951ce48779180c0473baae410bc80c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfc1ae73cc1f386b043ddd46326eda4"><td class="memItemLeft" align="right" valign="top">typedef String::ListBaseType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1dfc1ae73cc1f386b043ddd46326eda4">StringBase</a></td></tr>
<tr class="memdesc:ga1dfc1ae73cc1f386b043ddd46326eda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string typedef.  <a href="group___evo_containers.html#ga1dfc1ae73cc1f386b043ddd46326eda4">More...</a><br /></td></tr>
<tr class="separator:ga1dfc1ae73cc1f386b043ddd46326eda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d4f4ea3686689840d19597386b9776"><td class="memItemLeft" align="right" valign="top">typedef MapList&lt; String, String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga73d4f4ea3686689840d19597386b9776">StrMapList</a></td></tr>
<tr class="memdesc:ga73d4f4ea3686689840d19597386b9776"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_map_list.html" title="Map implemented as an ordered list. ">MapList</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> keys and values.  <a href="group___evo_containers.html#ga73d4f4ea3686689840d19597386b9776">More...</a><br /></td></tr>
<tr class="separator:ga73d4f4ea3686689840d19597386b9776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3e8cc2d9064c77f5464ec611388091"><td class="memItemLeft" align="right" valign="top">typedef SetHash&lt; String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1e3e8cc2d9064c77f5464ec611388091">StrSetHash</a></td></tr>
<tr class="memdesc:ga1e3e8cc2d9064c77f5464ec611388091"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_set_hash.html" title="Set implemented as a hash table. ">SetHash</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values.  <a href="group___evo_containers.html#ga1e3e8cc2d9064c77f5464ec611388091">More...</a><br /></td></tr>
<tr class="separator:ga1e3e8cc2d9064c77f5464ec611388091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1e9a01b59463183d19261ea54593b2"><td class="memItemLeft" align="right" valign="top">typedef SetList&lt; String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0f1e9a01b59463183d19261ea54593b2">StrSetList</a></td></tr>
<tr class="memdesc:ga0f1e9a01b59463183d19261ea54593b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_set_list.html" title="Set implemented as an ordered sequential array/list. ">SetList</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values.  <a href="group___evo_containers.html#ga0f1e9a01b59463183d19261ea54593b2">More...</a><br /></td></tr>
<tr class="separator:ga0f1e9a01b59463183d19261ea54593b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063daf12c7c0b1d1ae5d5194265a62e6"><td class="memItemLeft" align="right" valign="top">typedef Var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga063daf12c7c0b1d1ae5d5194265a62e6">VarList</a></td></tr>
<tr class="memdesc:ga063daf12c7c0b1d1ae5d5194265a62e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classevo_1_1_var.html" title="General purpose variable that can hold a basic value (string, number, bool, etc) or children with nes...">Var</a>, useful for explicitly passing a list to a <a class="el" href="classevo_1_1_var_object.html" title="Explicit variant of Var used for initializing as an object with an initializer list of key/value pair...">VarObject</a> field value (C++11).  <a href="group___evo_containers.html#ga063daf12c7c0b1d1ae5d5194265a62e6">More...</a><br /></td></tr>
<tr class="separator:ga063daf12c7c0b1d1ae5d5194265a62e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga558df9907996461d0b13492fd343c416"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga558df9907996461d0b13492fd343c416">CharBreakType</a> { <br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416a81d1f058b27fcc397431a15ff200d257">cbtOTHER</a> = 0, 
<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416a43dd2b9988fbff40074fbfd13ebb64f5">cbtWSPACE</a>, 
<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416ac96c6ba66b4d1e6b1dcf9ffb570159c7">cbtQUOTE</a>, 
<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416a67b3ec2d9f81f98b116b5b4b11ea3536">cbtBEGIN</a>, 
<br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416a80474ef81ff3391a8b0164940884b422">cbtEND</a>, 
<a class="el" href="group___evo_containers.html#gga558df9907996461d0b13492fd343c416a51eb02b324494131203ae8ffb8b92636">cbtWORD</a>
<br />
 }<tr class="memdesc:ga558df9907996461d0b13492fd343c416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character break type returned by <a class="el" href="group___evo_containers.html#ga9331cc2f8106525f8cc7b2fe564011c0" title="Get ASCII character word-break type. ">ascii_breaktype()</a>.  <a href="group___evo_containers.html#ga558df9907996461d0b13492fd343c416">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga558df9907996461d0b13492fd343c416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29966b9994a4b4e8c250133a79f4a2e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga29966b9994a4b4e8c250133a79f4a2e0">CharType</a> { <br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0abed84ee63ee7d297aa36bc97e7c773ac">ctOTHER</a> = 0, 
<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0a07e50fdda5e47b27ed480590ab64fc7b">ctWSPACE</a>, 
<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0aba32aa5b9440c88983117d783fb92366">ctPUNCT</a>, 
<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0af683f76b5668d6f4bbf8b3c0267491d8">ctDIGIT</a>, 
<br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0a56aba297544cc13a73ccbf2ce6d99148">ctUPPER</a>, 
<a class="el" href="group___evo_containers.html#gga29966b9994a4b4e8c250133a79f4a2e0adf0fae83e0d51e1e3e5acc1c6d2339a7">ctLOWER</a>
<br />
 }<tr class="memdesc:ga29966b9994a4b4e8c250133a79f4a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character type returned by <a class="el" href="group___evo_containers.html#ga0bd0d06fab38d16c19beb13124c76b00" title="Get ASCII character type. ">ascii_type()</a>.  <a href="group___evo_containers.html#ga29966b9994a4b4e8c250133a79f4a2e0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga29966b9994a4b4e8c250133a79f4a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573874d977e2b22545076ff4c9e498b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga573874d977e2b22545076ff4c9e498b8">FmtAlign</a> { <a class="el" href="group___evo_containers.html#gga573874d977e2b22545076ff4c9e498b8a2276169c80f2b84eacc95e5d106b490e">faCURRENT</a> = 0, 
<a class="el" href="group___evo_containers.html#gga573874d977e2b22545076ff4c9e498b8abde979ec06a763810d6592fd9ffab4b1">fLEFT</a>, 
<a class="el" href="group___evo_containers.html#gga573874d977e2b22545076ff4c9e498b8a8223960e6599779c962fa8a84c7599ff">fCENTER</a>, 
<a class="el" href="group___evo_containers.html#gga573874d977e2b22545076ff4c9e498b8a08921c0cd9efedb68d9987bac05757f7">fRIGHT</a>
 }<tr class="memdesc:ga573874d977e2b22545076ff4c9e498b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting alignment.  <a href="group___evo_containers.html#ga573874d977e2b22545076ff4c9e498b8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga573874d977e2b22545076ff4c9e498b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e52ddd0c4be8a2754bbcfdf5bffe35"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga04e52ddd0c4be8a2754bbcfdf5bffe35">FmtBase</a> { <br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a80de1dcbd5c7cf4e014902c37ecaf7d7">fbCURRENT</a> = 0, 
<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a0ebebc5fe5b2a70944fbc66dc43460db">fbAUTO</a> = 0, 
<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a88653bddc3b0f17b1f4dde1e629739b7">fBIN</a> = 2, 
<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a685b13f40dbfac927e379fd66e0f9e23">fOCT</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a> = 10, 
<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a> = 16, 
<a class="el" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35afebac51b4693152a1b5e843838b7dc94">fHEXL</a> = 116
<br />
 }<tr class="memdesc:ga04e52ddd0c4be8a2754bbcfdf5bffe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting integer base.  <a href="group___evo_containers.html#ga04e52ddd0c4be8a2754bbcfdf5bffe35">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga04e52ddd0c4be8a2754bbcfdf5bffe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe3009144f6921cb7e75b7b7bd50794"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga5fe3009144f6921cb7e75b7b7bd50794">FmtBasePrefix</a> { <a class="el" href="group___evo_containers.html#gga5fe3009144f6921cb7e75b7b7bd50794a5fc856c0f2df365518cfa36a8b16231a">fbpCURRENT</a> = 0, 
<a class="el" href="group___evo_containers.html#gga5fe3009144f6921cb7e75b7b7bd50794ade051764b644fa6745ca356c4b556688">fPREFIX0</a>, 
<a class="el" href="group___evo_containers.html#gga5fe3009144f6921cb7e75b7b7bd50794a4c4e49d7ff4f48545c13909ca6c50ddb">fPREFIX1</a>, 
<a class="el" href="group___evo_containers.html#gga5fe3009144f6921cb7e75b7b7bd50794a666c28437a15a7c6f2fdef580575b1f6">fPREFIX2</a>
 }<tr class="memdesc:ga5fe3009144f6921cb7e75b7b7bd50794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting integer base prefix type.  <a href="group___evo_containers.html#ga5fe3009144f6921cb7e75b7b7bd50794">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga5fe3009144f6921cb7e75b7b7bd50794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b7b29e9676f4002cbc9f8079c339fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad9b7b29e9676f4002cbc9f8079c339fe">FmtPrecision</a> { <br />
&#160;&#160;<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea7af941d501c449527008e5034f9fef74">fpCURRENT</a> = -2, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339feae2ca8f83c6c0244b35d96b23eb0eb633">fPREC_AUTO</a> = -1, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea87279e40780f6c1c162bcbd9bddbb7dc">fPREC0</a> = 0, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea7d22727f3dc1b21f15ffbba30816ac2e">fPREC1</a>, 
<br />
&#160;&#160;<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fead4e92736684df38276daf8a50391e8cd">fPREC2</a>, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea9b9f37def2cd96072254821ae3b793d7">fPREC3</a>, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339feae83a06e260d39bcc7c2a4b8d90a58805">fPREC4</a>, 
<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea74758ba0e567b7cea8437be9217bdab4">fPREC5</a>, 
<br />
&#160;&#160;<a class="el" href="group___evo_containers.html#ggad9b7b29e9676f4002cbc9f8079c339fea225c52e0cb8b48e1394fe477e13cb533">fPREC6</a>
<br />
 }<tr class="memdesc:gad9b7b29e9676f4002cbc9f8079c339fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting floating point precision type.  <a href="group___evo_containers.html#gad9b7b29e9676f4002cbc9f8079c339fe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gad9b7b29e9676f4002cbc9f8079c339fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ad17c5e7e041c24796fdfcf86e03ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaa7ad17c5e7e041c24796fdfcf86e03ec">FmtWidth</a> { <a class="el" href="group___evo_containers.html#ggaa7ad17c5e7e041c24796fdfcf86e03ecabbdbb4b24490f99b1a5a8e72deb96335">fWIDTH0</a> = 0
 }<tr class="memdesc:gaa7ad17c5e7e041c24796fdfcf86e03ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting field width.  <a href="group___evo_containers.html#gaa7ad17c5e7e041c24796fdfcf86e03ec">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaa7ad17c5e7e041c24796fdfcf86e03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf8b8c6f2e45d38c1e6be72cc3a066c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaaaf8b8c6f2e45d38c1e6be72cc3a066c">IteratorDir</a> { <a class="el" href="group___evo_containers.html#ggaaaf8b8c6f2e45d38c1e6be72cc3a066ca2076541f903f88f61fa9c14dfb4b6ef0">iterNONE</a>, 
<a class="el" href="group___evo_containers.html#ggaaaf8b8c6f2e45d38c1e6be72cc3a066cade6b4782743b684c938ae826329d1b0a">iterFW</a>, 
<a class="el" href="group___evo_containers.html#ggaaaf8b8c6f2e45d38c1e6be72cc3a066ca0b917fbd8a8a5db56105f5f499443eaf">iterRV</a>
 }<tr class="memdesc:gaaaf8b8c6f2e45d38c1e6be72cc3a066c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator direction value.  <a href="group___evo_containers.html#gaaaf8b8c6f2e45d38c1e6be72cc3a066c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaaaf8b8c6f2e45d38c1e6be72cc3a066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8bed56091b38cec628d3aa8ce3f225"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga8e8bed56091b38cec628d3aa8ce3f225">IteratorPos</a> { <a class="el" href="group___evo_containers.html#gga8e8bed56091b38cec628d3aa8ce3f225aba95ce54f7de8cba91306c3325ba4ed5">iterFIRST</a>, 
<a class="el" href="group___evo_containers.html#gga8e8bed56091b38cec628d3aa8ce3f225afa04bcd8bb52e56e9ffe697137527978">iterLAST</a>, 
<a class="el" href="group___evo_containers.html#gga8e8bed56091b38cec628d3aa8ce3f225ab80c386cac5dd30fb3dbc842dcf00e0b">iterEND</a>
 }<tr class="memdesc:ga8e8bed56091b38cec628d3aa8ce3f225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator position value.  <a href="group___evo_containers.html#ga8e8bed56091b38cec628d3aa8ce3f225">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8e8bed56091b38cec628d3aa8ce3f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a119b4837a0f787a2fc499fc5409b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga26a119b4837a0f787a2fc499fc5409b3">StringSearchAlg</a> { <a class="el" href="group___evo_containers.html#gga26a119b4837a0f787a2fc499fc5409b3a6ee5e8e291012c76f90cbaf0267c25d5">ssaDEFAULT</a> =0, 
<a class="el" href="group___evo_containers.html#gga26a119b4837a0f787a2fc499fc5409b3af7647a8d0023f6c0e8223e9949293b10">ssaKMP</a>, 
<a class="el" href="group___evo_containers.html#gga26a119b4837a0f787a2fc499fc5409b3ae9c6bc5a5b6418deca7b9c60430c6a6e">ssaBASIC</a>
 }<tr class="memdesc:ga26a119b4837a0f787a2fc499fc5409b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">String search algorithm selection.  <a href="group___evo_containers.html#ga26a119b4837a0f787a2fc499fc5409b3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga26a119b4837a0f787a2fc499fc5409b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d2de7e838006cdc9643397de60a761"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a> { <a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a>, 
<a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a>, 
<a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a>, 
<a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a>
 }<tr class="memdesc:gae9d2de7e838006cdc9643397de60a761"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF decoding mode used to set how to handle invalid character values.  <a href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gae9d2de7e838006cdc9643397de60a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9331cc2f8106525f8cc7b2fe564011c0"><td class="memItemLeft" align="right" valign="top">CharBreakType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga9331cc2f8106525f8cc7b2fe564011c0">ascii_breaktype</a> (char ch)</td></tr>
<tr class="memdesc:ga9331cc2f8106525f8cc7b2fe564011c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ASCII character word-break type.  <a href="group___evo_containers.html#ga9331cc2f8106525f8cc7b2fe564011c0">More...</a><br /></td></tr>
<tr class="separator:ga9331cc2f8106525f8cc7b2fe564011c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1940420bcd5613e0b46d3e6aa716cc84"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1940420bcd5613e0b46d3e6aa716cc84">ascii_tolower</a> (char ch)</td></tr>
<tr class="memdesc:ga1940420bcd5613e0b46d3e6aa716cc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ASCII character to lowercase.  <a href="group___evo_containers.html#ga1940420bcd5613e0b46d3e6aa716cc84">More...</a><br /></td></tr>
<tr class="separator:ga1940420bcd5613e0b46d3e6aa716cc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0c4eb6354d25b0603ce107e9ae347e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gabb0c4eb6354d25b0603ce107e9ae347e">ascii_toupper</a> (char ch)</td></tr>
<tr class="memdesc:gabb0c4eb6354d25b0603ce107e9ae347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ASCII character to uppercase.  <a href="group___evo_containers.html#gabb0c4eb6354d25b0603ce107e9ae347e">More...</a><br /></td></tr>
<tr class="separator:gabb0c4eb6354d25b0603ce107e9ae347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd0d06fab38d16c19beb13124c76b00"><td class="memItemLeft" align="right" valign="top">CharType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0bd0d06fab38d16c19beb13124c76b00">ascii_type</a> (char ch)</td></tr>
<tr class="memdesc:ga0bd0d06fab38d16c19beb13124c76b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ASCII character type.  <a href="group___evo_containers.html#ga0bd0d06fab38d16c19beb13124c76b00">More...</a><br /></td></tr>
<tr class="separator:ga0bd0d06fab38d16c19beb13124c76b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633fe7675aa5dee3e6f52a017fe06530"><td class="memTemplParams" colspan="2">template&lt;class T , uint sz&gt; </td></tr>
<tr class="memitem:ga633fe7675aa5dee3e6f52a017fe06530"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a> (T(&amp;)[sz])</td></tr>
<tr class="memdesc:ga633fe7675aa5dee3e6f52a017fe06530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of fixed-length array.  <a href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">More...</a><br /></td></tr>
<tr class="separator:ga633fe7675aa5dee3e6f52a017fe06530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6961c21def82a6c398beab677e0c84bb"><td class="memTemplParams" colspan="2">template&lt;class TMap &gt; </td></tr>
<tr class="memitem:ga6961c21def82a6c398beab677e0c84bb"><td class="memTemplItemLeft" align="right" valign="top">SubString&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6961c21def82a6c398beab677e0c84bb">lookupsub</a> (const TMap &amp;map, const typename TMap::Key &amp;key)</td></tr>
<tr class="memdesc:ga6961c21def82a6c398beab677e0c84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (find) map value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> for given key.  <a href="group___evo_containers.html#ga6961c21def82a6c398beab677e0c84bb">More...</a><br /></td></tr>
<tr class="separator:ga6961c21def82a6c398beab677e0c84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0097d48e4f34c8a98a71c05867e933e1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0097d48e4f34c8a98a71c05867e933e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0097d48e4f34c8a98a71c05867e933e1">map_contains</a> (const T &amp;map, const typename T::Key &amp;key, const typename T::Value &amp;value)</td></tr>
<tr class="memdesc:ga0097d48e4f34c8a98a71c05867e933e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether map contains key with matching value.  <a href="group___evo_containers.html#ga0097d48e4f34c8a98a71c05867e933e1">More...</a><br /></td></tr>
<tr class="separator:ga0097d48e4f34c8a98a71c05867e933e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f47ce2762188e63861b2b6b51614ef0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6f47ce2762188e63861b2b6b51614ef0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6f47ce2762188e63861b2b6b51614ef0">operator!=</a> (const BitArraySubsetT&lt; BitArrayT&lt; T &gt; &gt; &amp;a, const BitArrayT&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ga6f47ce2762188e63861b2b6b51614ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="group___evo_containers.html#ga6f47ce2762188e63861b2b6b51614ef0">More...</a><br /></td></tr>
<tr class="separator:ga6f47ce2762188e63861b2b6b51614ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcb8fa4ea9227be274b204e9a07c318"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9fcb8fa4ea9227be274b204e9a07c318"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga9fcb8fa4ea9227be274b204e9a07c318">operator==</a> (const BitArraySubsetT&lt; BitArrayT&lt; T &gt; &gt; &amp;a, const BitArrayT&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ga9fcb8fa4ea9227be274b204e9a07c318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="group___evo_containers.html#ga9fcb8fa4ea9227be274b204e9a07c318">More...</a><br /></td></tr>
<tr class="separator:ga9fcb8fa4ea9227be274b204e9a07c318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6172578257a7c375f20e923b29adeb95"><td class="memTemplParams" colspan="2">template&lt;class TMap &gt; </td></tr>
<tr class="memitem:ga6172578257a7c375f20e923b29adeb95"><td class="memTemplItemLeft" align="right" valign="top">const TMap::mapped_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6172578257a7c375f20e923b29adeb95">stdlookup</a> (const TMap &amp;map, const typename TMap::key_type &amp;key)</td></tr>
<tr class="memdesc:ga6172578257a7c375f20e923b29adeb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (find) STL map value for given key (const).  <a href="group___evo_containers.html#ga6172578257a7c375f20e923b29adeb95">More...</a><br /></td></tr>
<tr class="separator:ga6172578257a7c375f20e923b29adeb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef9f8c5fda1724c2b4294e34993f2f7"><td class="memTemplParams" colspan="2">template&lt;class TMap &gt; </td></tr>
<tr class="memitem:gacef9f8c5fda1724c2b4294e34993f2f7"><td class="memTemplItemLeft" align="right" valign="top">TMap::mapped_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gacef9f8c5fda1724c2b4294e34993f2f7">stdlookupM</a> (TMap &amp;map, const typename TMap::key_type &amp;key)</td></tr>
<tr class="memdesc:gacef9f8c5fda1724c2b4294e34993f2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (find) STL map value for given key (mutable).  <a href="group___evo_containers.html#gacef9f8c5fda1724c2b4294e34993f2f7">More...</a><br /></td></tr>
<tr class="separator:gacef9f8c5fda1724c2b4294e34993f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d1ffc3283fda3d4f87ab26e3837914"><td class="memTemplParams" colspan="2">template&lt;class TMap &gt; </td></tr>
<tr class="memitem:ga94d1ffc3283fda3d4f87ab26e3837914"><td class="memTemplItemLeft" align="right" valign="top">SubString&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914">stdlookupsub</a> (const TMap &amp;map, const typename TMap::key_type &amp;key)</td></tr>
<tr class="memdesc:ga94d1ffc3283fda3d4f87ab26e3837914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup (find) STL map value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> for given key.  <a href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914">More...</a><br /></td></tr>
<tr class="separator:ga94d1ffc3283fda3d4f87ab26e3837914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559960ce2025c5d1c7434e49c2631c30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga559960ce2025c5d1c7434e49c2631c30">str_scan_backtickdel</a> (const char *str, const char *end)</td></tr>
<tr class="memdesc:ga559960ce2025c5d1c7434e49c2631c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string for a Backtick + DEL pair.  <a href="group___evo_containers.html#ga559960ce2025c5d1c7434e49c2631c30">More...</a><br /></td></tr>
<tr class="separator:ga559960ce2025c5d1c7434e49c2631c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712ceba93c0e95af8764611c83f8484c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga712ceba93c0e95af8764611c83f8484c"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga712ceba93c0e95af8764611c83f8484c">str_scan_decimal</a> (T &amp;num, const char *str, const char *end)</td></tr>
<tr class="memdesc:ga712ceba93c0e95af8764611c83f8484c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for decimal number and return stop pointer.  <a href="group___evo_containers.html#ga712ceba93c0e95af8764611c83f8484c">More...</a><br /></td></tr>
<tr class="separator:ga712ceba93c0e95af8764611c83f8484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af9672ca4ae539186fdcc796ab030e5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga7af9672ca4ae539186fdcc796ab030e5">str_scan_delim</a> (const char *str, const char *end, char delim1, char delim2)</td></tr>
<tr class="memdesc:ga7af9672ca4ae539186fdcc796ab030e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter and return stop pointer.  <a href="group___evo_containers.html#ga7af9672ca4ae539186fdcc796ab030e5">More...</a><br /></td></tr>
<tr class="separator:ga7af9672ca4ae539186fdcc796ab030e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d50640e5d8cb86df38e2ef6e21e37a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad0d50640e5d8cb86df38e2ef6e21e37a">str_scan_delim</a> (const char *str, const char *end, const char *delims, uint delim_count)</td></tr>
<tr class="memdesc:gad0d50640e5d8cb86df38e2ef6e21e37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter and return stop pointer.  <a href="group___evo_containers.html#gad0d50640e5d8cb86df38e2ef6e21e37a">More...</a><br /></td></tr>
<tr class="separator:gad0d50640e5d8cb86df38e2ef6e21e37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd1ba030b49a27b67198f6ae50dadfa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0bd1ba030b49a27b67198f6ae50dadfa">str_scan_delim_r</a> (const char *str, const char *end, char delim1, char delim2)</td></tr>
<tr class="memdesc:ga0bd1ba030b49a27b67198f6ae50dadfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter in reverse and return new end after stop pointer.  <a href="group___evo_containers.html#ga0bd1ba030b49a27b67198f6ae50dadfa">More...</a><br /></td></tr>
<tr class="separator:ga0bd1ba030b49a27b67198f6ae50dadfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1bf2d286b9fabe41740baa8d0292a6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1f1bf2d286b9fabe41740baa8d0292a6">str_scan_delim_r</a> (const char *str, const char *end, const char *delims, uint delim_count)</td></tr>
<tr class="memdesc:ga1f1bf2d286b9fabe41740baa8d0292a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter in reverse and return new end after stop pointer.  <a href="group___evo_containers.html#ga1f1bf2d286b9fabe41740baa8d0292a6">More...</a><br /></td></tr>
<tr class="separator:ga1f1bf2d286b9fabe41740baa8d0292a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d987241324d938dbb488d309b1fa4c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga4d987241324d938dbb488d309b1fa4c9">str_scan_endq</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end)</td></tr>
<tr class="memdesc:ga4d987241324d938dbb488d309b1fa4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer and extract quoted or unquoted text.  <a href="group___evo_containers.html#ga4d987241324d938dbb488d309b1fa4c9">More...</a><br /></td></tr>
<tr class="separator:ga4d987241324d938dbb488d309b1fa4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424e8d1bad91b18295caa7a3b424b08d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga424e8d1bad91b18295caa7a3b424b08d">str_scan_endq</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end, char delim)</td></tr>
<tr class="memdesc:ga424e8d1bad91b18295caa7a3b424b08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer and extract quoted or unquoted text with a delimiter.  <a href="group___evo_containers.html#ga424e8d1bad91b18295caa7a3b424b08d">More...</a><br /></td></tr>
<tr class="separator:ga424e8d1bad91b18295caa7a3b424b08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d4d2e5cce221a47f26327e2fa3cd77"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad1d4d2e5cce221a47f26327e2fa3cd77">str_scan_endq</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end, char delim1, char delim2)</td></tr>
<tr class="memdesc:gad1d4d2e5cce221a47f26327e2fa3cd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer and extract quoted or unquoted text with 2 possible delimiters.  <a href="group___evo_containers.html#gad1d4d2e5cce221a47f26327e2fa3cd77">More...</a><br /></td></tr>
<tr class="separator:gad1d4d2e5cce221a47f26327e2fa3cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7824467a59d7aee8612dfd7e74ee760"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaa7824467a59d7aee8612dfd7e74ee760">str_scan_endq</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end, const char *delims, uint delim_count, char ws_delim=0)</td></tr>
<tr class="memdesc:gaa7824467a59d7aee8612dfd7e74ee760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer and extract quoted or unquoted text with multiple possible delimiters.  <a href="group___evo_containers.html#gaa7824467a59d7aee8612dfd7e74ee760">More...</a><br /></td></tr>
<tr class="separator:gaa7824467a59d7aee8612dfd7e74ee760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259128db4798e6c8d377ffb25668c9e0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga259128db4798e6c8d377ffb25668c9e0">str_scan_endq_r</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end, char delim)</td></tr>
<tr class="memdesc:ga259128db4798e6c8d377ffb25668c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer in reverse and extract quoted or unquoted text with a delimiter and return new end after stop pointer.  <a href="group___evo_containers.html#ga259128db4798e6c8d377ffb25668c9e0">More...</a><br /></td></tr>
<tr class="separator:ga259128db4798e6c8d377ffb25668c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be2483cee503b8ae406e7f1b7c14432"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga9be2483cee503b8ae406e7f1b7c14432">str_scan_endq_r</a> (const char *&amp;startq, const char *&amp;endq, const char *str, const char *end, const char *delims, uint delim_count, char ws_delim=0)</td></tr>
<tr class="memdesc:ga9be2483cee503b8ae406e7f1b7c14432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer in reverse and extract quoted or unquoted text with multiple possible delimiters and return new end after stop pointer.  <a href="group___evo_containers.html#ga9be2483cee503b8ae406e7f1b7c14432">More...</a><br /></td></tr>
<tr class="separator:ga9be2483cee503b8ae406e7f1b7c14432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227636a7c9549757d059948b4a2543dc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga227636a7c9549757d059948b4a2543dc"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga227636a7c9549757d059948b4a2543dc">str_scan_hex</a> (T &amp;num, const char *str, const char *end)</td></tr>
<tr class="memdesc:ga227636a7c9549757d059948b4a2543dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for hex number and return stop pointer.  <a href="group___evo_containers.html#ga227636a7c9549757d059948b4a2543dc">More...</a><br /></td></tr>
<tr class="separator:ga227636a7c9549757d059948b4a2543dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e971eb1c263d72a704a493621d8b1e2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6e971eb1c263d72a704a493621d8b1e2">str_scan_ndelim</a> (const char *str, const char *end, char delim1, char delim2)</td></tr>
<tr class="memdesc:ga6e971eb1c263d72a704a493621d8b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next non-delimiter and return stop pointer.  <a href="group___evo_containers.html#ga6e971eb1c263d72a704a493621d8b1e2">More...</a><br /></td></tr>
<tr class="separator:ga6e971eb1c263d72a704a493621d8b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be60ca2f9faf381f7a2cbab9d949c06"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga4be60ca2f9faf381f7a2cbab9d949c06">str_scan_ndelim_r</a> (const char *str, const char *end, char delim1, char delim2)</td></tr>
<tr class="memdesc:ga4be60ca2f9faf381f7a2cbab9d949c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next non-delimiter in reverse and return new end after stop pointer.  <a href="group___evo_containers.html#ga4be60ca2f9faf381f7a2cbab9d949c06">More...</a><br /></td></tr>
<tr class="separator:ga4be60ca2f9faf381f7a2cbab9d949c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5799401683473661a8fd1362508c6f9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gab5799401683473661a8fd1362508c6f9">str_scan_nws</a> (const char *str, const char *end)</td></tr>
<tr class="memdesc:gab5799401683473661a8fd1362508c6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next non-whitespace character and return stop pointer.  <a href="group___evo_containers.html#gab5799401683473661a8fd1362508c6f9">More...</a><br /></td></tr>
<tr class="separator:gab5799401683473661a8fd1362508c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fb88707879c77dbbf50cad558d101e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gac4fb88707879c77dbbf50cad558d101e">str_scan_nws</a> (const char *str, const char *end, char delim)</td></tr>
<tr class="memdesc:gac4fb88707879c77dbbf50cad558d101e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter or non-whitespace character and return stop pointer.  <a href="group___evo_containers.html#gac4fb88707879c77dbbf50cad558d101e">More...</a><br /></td></tr>
<tr class="separator:gac4fb88707879c77dbbf50cad558d101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67034d1c3b7bc59a8041f6fe74949127"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga67034d1c3b7bc59a8041f6fe74949127">str_scan_nws_r</a> (const char *str, const char *end)</td></tr>
<tr class="memdesc:ga67034d1c3b7bc59a8041f6fe74949127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next non-whitespace character in reverse and return new end after stop pointer.  <a href="group___evo_containers.html#ga67034d1c3b7bc59a8041f6fe74949127">More...</a><br /></td></tr>
<tr class="separator:ga67034d1c3b7bc59a8041f6fe74949127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad271596747e9b82677a1c9c110353668"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gad271596747e9b82677a1c9c110353668">str_scan_nws_r</a> (const char *str, const char *end, char delim)</td></tr>
<tr class="memdesc:gad271596747e9b82677a1c9c110353668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for next delimiter or non-whitespace character and return stop pointer.  <a href="group___evo_containers.html#gad271596747e9b82677a1c9c110353668">More...</a><br /></td></tr>
<tr class="separator:gad271596747e9b82677a1c9c110353668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2364b09ca1b3814c3ee45a39934f3456"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga2364b09ca1b3814c3ee45a39934f3456">str_scan_to</a> (uint maxlen, const char *str, const char *end, char ch)</td></tr>
<tr class="memdesc:ga2364b09ca1b3814c3ee45a39934f3456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for char and return stop pointer.  <a href="group___evo_containers.html#ga2364b09ca1b3814c3ee45a39934f3456">More...</a><br /></td></tr>
<tr class="separator:ga2364b09ca1b3814c3ee45a39934f3456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c26a278301a1078074257c00d15374"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaf0c26a278301a1078074257c00d15374">str_scan_to</a> (uint maxlen, const char *str, const char *end, char ch1, char ch2)</td></tr>
<tr class="memdesc:gaf0c26a278301a1078074257c00d15374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string pointer for either of 2 chars and return stop pointer.  <a href="group___evo_containers.html#gaf0c26a278301a1078074257c00d15374">More...</a><br /></td></tr>
<tr class="separator:gaf0c26a278301a1078074257c00d15374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4931e8d7dec87ad316cb11f2d2f6dd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6e4931e8d7dec87ad316cb11f2d2f6dd">string_memrchr</a> (const char *str, char ch, size_t size)</td></tr>
<tr class="memdesc:ga6e4931e8d7dec87ad316cb11f2d2f6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evo implementation of memrchr() to search for character in reverse.  <a href="group___evo_containers.html#ga6e4931e8d7dec87ad316cb11f2d2f6dd">More...</a><br /></td></tr>
<tr class="separator:ga6e4931e8d7dec87ad316cb11f2d2f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74613d1a4da699a72378124e9c4d415a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga74613d1a4da699a72378124e9c4d415a">utf16_compare</a> (const wchar16 *str1, ulong len1, const wchar16 *str2, ulong len2)</td></tr>
<tr class="memdesc:ga74613d1a4da699a72378124e9c4d415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two non-terminated UTF-16 strings.  <a href="group___evo_containers.html#ga74613d1a4da699a72378124e9c4d415a">More...</a><br /></td></tr>
<tr class="separator:ga74613d1a4da699a72378124e9c4d415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5280554190c9effb26dafacc9636bc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gac5280554190c9effb26dafacc9636bc2">utf16_compare</a> (const wchar16 *str1, ulong len1, const wchar16 *str2)</td></tr>
<tr class="memdesc:gac5280554190c9effb26dafacc9636bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a non-terminated UTF-16 string with a terminated UTF-16 string.  <a href="group___evo_containers.html#gac5280554190c9effb26dafacc9636bc2">More...</a><br /></td></tr>
<tr class="separator:gac5280554190c9effb26dafacc9636bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6338569f372bc94c75e87b2ac2853133"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga6338569f372bc94c75e87b2ac2853133">utf16_compare</a> (const wchar16 *str1, const wchar16 *str2)</td></tr>
<tr class="memdesc:ga6338569f372bc94c75e87b2ac2853133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two terminated UTF-16 strings.  <a href="group___evo_containers.html#ga6338569f372bc94c75e87b2ac2853133">More...</a><br /></td></tr>
<tr class="separator:ga6338569f372bc94c75e87b2ac2853133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833d6bcd2b8682b226b049ed3842f6f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga833d6bcd2b8682b226b049ed3842f6f2">utf16_compare8</a> (const wchar16 *str1, ulong len1, const char *str2, ulong len2)</td></tr>
<tr class="memdesc:ga833d6bcd2b8682b226b049ed3842f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a non-terminated UTF-16 string to a non-terminated UTF-8 string.  <a href="group___evo_containers.html#ga833d6bcd2b8682b226b049ed3842f6f2">More...</a><br /></td></tr>
<tr class="separator:ga833d6bcd2b8682b226b049ed3842f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a638442adea48b28e8dfd1464beb80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga5a638442adea48b28e8dfd1464beb80f">utf16_compare8</a> (const wchar16 *str1, ulong len1, const char *str2)</td></tr>
<tr class="memdesc:ga5a638442adea48b28e8dfd1464beb80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a non-terminated UTF-16 string to a terminated UTF-8 string.  <a href="group___evo_containers.html#ga5a638442adea48b28e8dfd1464beb80f">More...</a><br /></td></tr>
<tr class="separator:ga5a638442adea48b28e8dfd1464beb80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef49877387b9318aad8a35bf4ea87d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0ef49877387b9318aad8a35bf4ea87d3">utf16_compare8</a> (const wchar16 *str1, const char *str2)</td></tr>
<tr class="memdesc:ga0ef49877387b9318aad8a35bf4ea87d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a terminated UTF-16 string to a terminated UTF-8 string.  <a href="group___evo_containers.html#ga0ef49877387b9318aad8a35bf4ea87d3">More...</a><br /></td></tr>
<tr class="separator:ga0ef49877387b9318aad8a35bf4ea87d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b43536760d88299f94b813aa2d12d8"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga92b43536760d88299f94b813aa2d12d8">utf16_count</a> (const wchar16 *str, const wchar16 *end, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga92b43536760d88299f94b813aa2d12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Unicode character values in UTF-16 string.  <a href="group___evo_containers.html#ga92b43536760d88299f94b813aa2d12d8">More...</a><br /></td></tr>
<tr class="separator:ga92b43536760d88299f94b813aa2d12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e56577dae084dd79781bb646f4e9806"><td class="memItemLeft" align="right" valign="top">const wchar16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga1e56577dae084dd79781bb646f4e9806">utf16_min</a> (const wchar16 *str, const wchar16 *end, bool strict=false, uint mincount=1)</td></tr>
<tr class="memdesc:ga1e56577dae084dd79781bb646f4e9806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for UTF-16 surrogate pairs, which each require a pair of wchar16 values (4 bytes).  <a href="group___evo_containers.html#ga1e56577dae084dd79781bb646f4e9806">More...</a><br /></td></tr>
<tr class="separator:ga1e56577dae084dd79781bb646f4e9806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9742b1c299ff73b16b1f37c7c7c3a6c5"><td class="memItemLeft" align="right" valign="top">const wchar16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga9742b1c299ff73b16b1f37c7c7c3a6c5">utf16_scan</a> (wchar32 &amp;code, const wchar16 *str, const wchar16 *end, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga9742b1c299ff73b16b1f37c7c7c3a6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for next Unicode character in UTF-16 string.  <a href="group___evo_containers.html#ga9742b1c299ff73b16b1f37c7c7c3a6c5">More...</a><br /></td></tr>
<tr class="separator:ga9742b1c299ff73b16b1f37c7c7c3a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9f49b0f69d0749993baf0ba6dbcdf2"><td class="memItemLeft" align="right" valign="top">const wchar16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga0b9f49b0f69d0749993baf0ba6dbcdf2">utf16_scan_term</a> (wchar32 &amp;code, const wchar16 *str, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga0b9f49b0f69d0749993baf0ba6dbcdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for next Unicode character in terminated UTF-16 string.  <a href="group___evo_containers.html#ga0b9f49b0f69d0749993baf0ba6dbcdf2">More...</a><br /></td></tr>
<tr class="separator:ga0b9f49b0f69d0749993baf0ba6dbcdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1b4e33cb99a4f3d286f8192f7f6ce0"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga8f1b4e33cb99a4f3d286f8192f7f6ce0">utf16_strlen</a> (const wchar16 *str)</td></tr>
<tr class="memdesc:ga8f1b4e33cb99a4f3d286f8192f7f6ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find terminated UTF-16 string length.  <a href="group___evo_containers.html#ga8f1b4e33cb99a4f3d286f8192f7f6ce0">More...</a><br /></td></tr>
<tr class="separator:ga8f1b4e33cb99a4f3d286f8192f7f6ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbf51b006c81323205810e32e8add70"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga3dbf51b006c81323205810e32e8add70">utf16_to8</a> (const wchar16 *&amp;str, const wchar16 *end, char *outbuf=NULL, ulong outsize=0, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga3dbf51b006c81323205810e32e8add70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-16 string to UTF-8 string.  <a href="group___evo_containers.html#ga3dbf51b006c81323205810e32e8add70">More...</a><br /></td></tr>
<tr class="separator:ga3dbf51b006c81323205810e32e8add70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cd7d72857428ef143e31487681857f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga30cd7d72857428ef143e31487681857f">utf8_compare</a> (const char *str1, ulong len1, const char *str2, ulong len2)</td></tr>
<tr class="memdesc:ga30cd7d72857428ef143e31487681857f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two non-terminated UTF-8 strings.  <a href="group___evo_containers.html#ga30cd7d72857428ef143e31487681857f">More...</a><br /></td></tr>
<tr class="separator:ga30cd7d72857428ef143e31487681857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888b93d184e26c70d1413f638286e133"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga888b93d184e26c70d1413f638286e133">utf8_compare</a> (const char *str1, ulong len1, const char *str2)</td></tr>
<tr class="memdesc:ga888b93d184e26c70d1413f638286e133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare non-terminated and terminated UTF-8 strings.  <a href="group___evo_containers.html#ga888b93d184e26c70d1413f638286e133">More...</a><br /></td></tr>
<tr class="separator:ga888b93d184e26c70d1413f638286e133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d3926c1e241f6c91caef16fda2e115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga08d3926c1e241f6c91caef16fda2e115">utf8_compare</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:ga08d3926c1e241f6c91caef16fda2e115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two terminated UTF-8 strings.  <a href="group___evo_containers.html#ga08d3926c1e241f6c91caef16fda2e115">More...</a><br /></td></tr>
<tr class="separator:ga08d3926c1e241f6c91caef16fda2e115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49e468722a9f3152ec1eda12b9c1c44"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#gaa49e468722a9f3152ec1eda12b9c1c44">utf8_count</a> (const char *str, const char *end, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:gaa49e468722a9f3152ec1eda12b9c1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Unicode character values in UTF-8 string.  <a href="group___evo_containers.html#gaa49e468722a9f3152ec1eda12b9c1c44">More...</a><br /></td></tr>
<tr class="separator:gaa49e468722a9f3152ec1eda12b9c1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41bfd5eac7a114cced29fa66e8796561"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga41bfd5eac7a114cced29fa66e8796561">utf8_min</a> (const char *str, const char *end, bool strict=false, ulong mincount=1, uint minsize=2)</td></tr>
<tr class="memdesc:ga41bfd5eac7a114cced29fa66e8796561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for UTF-8 multi-byte characters of at least minsize.  <a href="group___evo_containers.html#ga41bfd5eac7a114cced29fa66e8796561">More...</a><br /></td></tr>
<tr class="separator:ga41bfd5eac7a114cced29fa66e8796561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f664abecc08952b89e03c285b0f180c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga7f664abecc08952b89e03c285b0f180c">utf8_scan</a> (wchar32 &amp;code, const char *str, const char *end, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga7f664abecc08952b89e03c285b0f180c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for next Unicode character in UTF-8 string.  <a href="group___evo_containers.html#ga7f664abecc08952b89e03c285b0f180c">More...</a><br /></td></tr>
<tr class="separator:ga7f664abecc08952b89e03c285b0f180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e46ab59bced3ecab5a31031ed5e000"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga21e46ab59bced3ecab5a31031ed5e000">utf8_scan_term</a> (wchar32 &amp;code, const char *str, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga21e46ab59bced3ecab5a31031ed5e000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for next Unicode character in terminated UTF-8 string.  <a href="group___evo_containers.html#ga21e46ab59bced3ecab5a31031ed5e000">More...</a><br /></td></tr>
<tr class="separator:ga21e46ab59bced3ecab5a31031ed5e000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c8368370a8c3c8e4f4a8f251292608"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga70c8368370a8c3c8e4f4a8f251292608">utf8_to16</a> (const char *&amp;str, const char *end, wchar16 *outbuf=NULL, ulong outsize=0, UtfMode mode=umREPLACE_INVALID)</td></tr>
<tr class="memdesc:ga70c8368370a8c3c8e4f4a8f251292608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to UTF-16 string.  <a href="group___evo_containers.html#ga70c8368370a8c3c8e4f4a8f251292608">More...</a><br /></td></tr>
<tr class="separator:ga70c8368370a8c3c8e4f4a8f251292608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga62f7c1d38790be092e1afa04b0586f58"><td class="memItemLeft" align="right" valign="top">static const wchar16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a> = 0xFFFD</td></tr>
<tr class="memdesc:ga62f7c1d38790be092e1afa04b0586f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unicode code point for "Replacement Character" used when decoding invalid UTF bytes or values.  <a href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">More...</a><br /></td></tr>
<tr class="separator:ga62f7c1d38790be092e1afa04b0586f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Evo containers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga4b7b4d2b7ae0e14ea11353b2a512788f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_CLASS_MAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>ENUM ## Enum { \</div><div class="line">            typedef ENUM Type; \</div><div class="line">            typedef EnumMapIterator&lt; ENUM ## Enum &gt; Iter; \</div><div class="line">            static <span class="keyword">const</span> ENUM FIRST = (ENUM)((<span class="keywordtype">int</span>)(ENUM::UNKNOWN) + 1); \</div><div class="line">            static <span class="keyword">const</span> ENUM LAST = (ENUM)((<span class="keywordtype">int</span>)(ENUM::ENUM_END) - 1); \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a>&amp; map() { \</div><div class="line">                static <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a> LIST[] = { __VA_ARGS__ }; \</div><div class="line">                static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a> MAP(LIST, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a>(LIST)); \</div><div class="line">                return MAP; \</div><div class="line">            } \</div><div class="line">            static ENUM get_enum(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a>&amp; key) \</div><div class="line">                { <span class="keywordflow">return</span> map().find_enum_class&lt;ENUM&gt;(key); } \</div><div class="line">            static ENUM get_enum(<span class="keywordtype">int</span> val) \</div><div class="line">                { <span class="keywordflow">return</span> (val &lt;= (<span class="keywordtype">int</span>)ENUM::UNKNOWN || val &gt;= (<span class="keywordtype">int</span>)ENUM::ENUM_END ? ENUM::UNKNOWN : (ENUM)val); } \</div><div class="line">            static <span class="keywordtype">int</span> get_int(ENUM val) \</div><div class="line">                { <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)val; } \</div><div class="line">            static SubString get_string(ENUM val) \</div><div class="line">                { <span class="keywordflow">return</span> map().get_enum_class_string(val); } \</div><div class="line">        }</div><div class="ttc" id="classevo_1_1_sub_string_map_list_html"><div class="ttname"><a href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a></div><div class="ttdoc">References a list of sorted substrings for fast lookup. </div><div class="ttdef"><b>Definition:</b> substring.h:1720</div></div>
<div class="ttc" id="group___evo_containers_html_ga633fe7675aa5dee3e6f52a017fe06530"><div class="ttname"><a href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a></div><div class="ttdeci">static uint fixed_array_size(T(&amp;)[sz])</div><div class="ttdoc">Get size of fixed-length array. </div><div class="ttdef"><b>Definition:</b> container.h:1104</div></div>
<div class="ttc" id="structevo_1_1_sub_string_html"><div class="ttname"><a href="structevo_1_1_sub_string.html">evo::SubString</a></div><div class="ttdoc">Reference and access existing string data. </div><div class="ttdef"><b>Definition:</b> substring.h:227</div></div>
</div><!-- fragment -->
<p>Helper for creating enum class string/value mappers (C++11). </p>
<ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>This creates a struct with traits that uses <a class="el" href="classevo_1_1_sub_string_map_list.html#a458581c11675326eca3a1d190b76d7e5">find_enum_class()</a> and <a class="el" href="classevo_1_1_sub_string_map_list.html#ab387706c299e5d753e56e56205f527d8">get_enum_class_string()</a></li>
<li>The created struct type is named after ENUM with suffix "Enum", and has helper functions:<ul>
<li>static ENUM get_enum(const evo::SubString&amp; key):<ul>
<li>Map string key to ENUM value</li>
</ul>
</li>
<li>static SubString get_string(ENUM value):<ul>
<li>Map ENUM value to string key, null if unknown</li>
</ul>
</li>
</ul>
</li>
<li><b>Caution:</b> The string values <em>must match ENUM and must be sorted</em></li>
<li>See example here: <a class="el" href="EnumConversion.html">Enum Conversion</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create mappings for </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad393c06275e73692f0e74d37f38e795b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_CLASS_REMAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">REMAP_ARRAY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>ENUM ## Enum { \</div><div class="line">            typedef ENUM Type; \</div><div class="line">            typedef EnumMapIterator&lt; ENUM ## Enum &gt; Iter; \</div><div class="line">            static <span class="keyword">const</span> ENUM FIRST = (ENUM)((<span class="keywordtype">int</span>)(ENUM::UNKNOWN) + 1); \</div><div class="line">            static <span class="keyword">const</span> ENUM LAST = (ENUM)((<span class="keywordtype">int</span>)(ENUM::ENUM_END) - 1); \</div><div class="line">            static <span class="keyword">const</span> ENUM* get_remap_array() { \</div><div class="line">                return REMAP_ARRAY; \</div><div class="line">            } \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>* get_reverse_remap_array() { \</div><div class="line">                static <span class="keyword">const</span> SubStringMapList::ReverseRemap&lt; ENUM ## Enum &gt; REVERSE(get_remap_array()); \</div><div class="line">                return REVERSE.array; \</div><div class="line">            } \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a>&amp; map() { \</div><div class="line">                static <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a> LIST[] = { __VA_ARGS__ }; \</div><div class="line">                static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a> MAP(LIST, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a>(LIST)); \</div><div class="line">                return MAP; \</div><div class="line">            } \</div><div class="line">            static ENUM get_enum(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a>&amp; key) \</div><div class="line">                { <span class="keywordflow">return</span> map().find_enum_remap&lt;Type&gt;(get_remap_array(), key, FIRST, LAST, Type::UNKNOWN); } \</div><div class="line">            static ENUM get_enum(<span class="keywordtype">int</span> val) \</div><div class="line">                { <span class="keywordflow">return</span> (val &lt;= (<span class="keywordtype">int</span>)ENUM::UNKNOWN || val &gt;= (<span class="keywordtype">int</span>)ENUM::ENUM_END ? ENUM::UNKNOWN : (ENUM)val); } \</div><div class="line">            static <span class="keywordtype">int</span> get_int(ENUM val) \</div><div class="line">                { <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)val; } \</div><div class="line">            static SubString get_string(ENUM val) \</div><div class="line">                { <span class="keywordflow">return</span> map().get_enum_string_remap(get_reverse_remap_array(), val, FIRST, LAST); } \</div><div class="line">        }</div><div class="ttc" id="classevo_1_1_sub_string_map_list_html"><div class="ttname"><a href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a></div><div class="ttdoc">References a list of sorted substrings for fast lookup. </div><div class="ttdef"><b>Definition:</b> substring.h:1720</div></div>
<div class="ttc" id="group___evo_containers_html_ga633fe7675aa5dee3e6f52a017fe06530"><div class="ttname"><a href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a></div><div class="ttdeci">static uint fixed_array_size(T(&amp;)[sz])</div><div class="ttdoc">Get size of fixed-length array. </div><div class="ttdef"><b>Definition:</b> container.h:1104</div></div>
<div class="ttc" id="namespaceevo_html_acc6c0a7a5a715e4a53f0833762b25c7f"><div class="ttname"><a href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">evo::SizeT</a></div><div class="ttdeci">uint32 SizeT</div><div class="ttdoc">Default Evo container size type. </div><div class="ttdef"><b>Definition:</b> sys.h:687</div></div>
<div class="ttc" id="structevo_1_1_sub_string_html"><div class="ttname"><a href="structevo_1_1_sub_string.html">evo::SubString</a></div><div class="ttdoc">Reference and access existing string data. </div><div class="ttdef"><b>Definition:</b> substring.h:227</div></div>
</div><!-- fragment -->
<p>Helper for creating enum class string/value mappers, with unsorted enum remapped to sorted values. </p>
<p>(C++11).</p><ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>This is a variant of <a class="el" href="group___evo_containers.html#ga4b7b4d2b7ae0e14ea11353b2a512788f" title="Helper for creating enum class string/value mappers (C++11). ">EVO_ENUM_CLASS_MAP()</a> for an unsorted enum</li>
<li>This uses <code>REMAP_ARRAY</code> to map an unsorted enum to sorted values &ndash; the data should be constant and static</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create mappings for </td></tr>
    <tr><td class="paramname">REMAP_ARRAY</td><td>Pointer to array of <code>ENUM</code> values sorted so they match the sorted string literals that follow </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab9e9898e6d31c9187eba0f588e348a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_MAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FIRST_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LAST_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">UNKNOWN_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>ENUM ## Enum { \</div><div class="line">        typedef ENUM Type; \</div><div class="line">        typedef EnumMapIterator&lt; ENUM ## Enum &gt; Iter; \</div><div class="line">        static <span class="keyword">const</span> ENUM FIRST   = FIRST_VAL; \</div><div class="line">        static <span class="keyword">const</span> ENUM LAST    = LAST_VAL; \</div><div class="line">        static <span class="keyword">const</span> ENUM UNKNOWN = UNKNOWN_VAL; \</div><div class="line">        static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a>&amp; map() { \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a> LIST[] = { __VA_ARGS__ }; \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a> MAP(LIST, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a>(LIST)); \</div><div class="line">            return MAP; \</div><div class="line">        } \</div><div class="line">        static ENUM get_enum(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a>&amp; key) \</div><div class="line">            { <span class="keywordflow">return</span> map().find_enum&lt;ENUM&gt;(key, FIRST, LAST, UNKNOWN); } \</div><div class="line">        static ENUM get_enum(<span class="keywordtype">int</span> val) \</div><div class="line">            { <span class="keywordflow">return</span> (val &lt; (<span class="keywordtype">int</span>)FIRST || val &gt; (<span class="keywordtype">int</span>)LAST ? UNKNOWN : (ENUM)val); } \</div><div class="line">        static <span class="keywordtype">int</span> get_int(ENUM val) \</div><div class="line">            { <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)val; } \</div><div class="line">        static SubString get_string(ENUM val) \</div><div class="line">            { <span class="keywordflow">return</span> map().get_enum_string(val, FIRST, LAST); } \</div><div class="line">    }</div><div class="ttc" id="classevo_1_1_sub_string_map_list_html"><div class="ttname"><a href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a></div><div class="ttdoc">References a list of sorted substrings for fast lookup. </div><div class="ttdef"><b>Definition:</b> substring.h:1720</div></div>
<div class="ttc" id="group___evo_containers_html_ga633fe7675aa5dee3e6f52a017fe06530"><div class="ttname"><a href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a></div><div class="ttdeci">static uint fixed_array_size(T(&amp;)[sz])</div><div class="ttdoc">Get size of fixed-length array. </div><div class="ttdef"><b>Definition:</b> container.h:1104</div></div>
<div class="ttc" id="structevo_1_1_sub_string_html"><div class="ttname"><a href="structevo_1_1_sub_string.html">evo::SubString</a></div><div class="ttdoc">Reference and access existing string data. </div><div class="ttdef"><b>Definition:</b> substring.h:227</div></div>
</div><!-- fragment -->
<p>Helper for creating enum string/value mappers with explicit first/last/unknown values. </p>
<ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>See better alternative: <a class="el" href="group___evo_containers.html#ga74dbbe26bf9a19598be4726357e31e81" title="Helper for creating enum string/value mappers with prefixed enum values. ">EVO_ENUM_MAP_PREFIXED()</a></li>
<li>This creates a struct with traits that uses <a class="el" href="classevo_1_1_sub_string_map_list.html#ad17a05a27e4f48ddb4b7f24bac5d5ba5">find_enum()</a> and <a class="el" href="classevo_1_1_sub_string_map_list.html#a635d895570a7728ddfc71a4946fad011">get_enum_string()</a></li>
<li>The created struct type is named after ENUM with suffix "Enum", and has helper functions:<ul>
<li>static ENUM get_enum(const evo::SubString&amp; key):<ul>
<li>Map string key to ENUM value</li>
</ul>
</li>
<li>static SubString get_string(ENUM value):<ul>
<li>Map ENUM value to string key, null if unknown</li>
</ul>
</li>
</ul>
</li>
<li><b>Caution:</b> The string values <em>must match ENUM and must be sorted</em></li>
<li>See: <a class="el" href="EnumConversion.html">Enum Conversion</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create traits for </td></tr>
    <tr><td class="paramname">FIRST_VAL</td><td>First enum value to map to, maps to first string </td></tr>
    <tr><td class="paramname">LAST_VAL</td><td>Last enum value to map to, maps to last string &ndash; must be &gt;= first_enum </td></tr>
    <tr><td class="paramname">UNKNOWN_VAL</td><td>Unknown enum value to use if key not found or result out of range </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74dbbe26bf9a19598be4726357e31e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_MAP_PREFIXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PREFIX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___evo_containers.html#gab9e9898e6d31c9187eba0f588e348a5d">EVO_ENUM_MAP</a>(ENUM, (ENUM)((int)(PREFIX ## UNKNOWN) + 1), (ENUM)((int)(PREFIX ## ENUM_END) - 1), PREFIX ## UNKNOWN, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for creating enum string/value mappers with prefixed enum values. </p>
<ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>This creates a struct with traits that uses <a class="el" href="classevo_1_1_sub_string_map_list.html#a458581c11675326eca3a1d190b76d7e5">find_enum_class()</a> and <a class="el" href="classevo_1_1_sub_string_map_list.html#ab387706c299e5d753e56e56205f527d8">get_enum_class_string()</a></li>
<li>The created struct type is named after ENUM with suffix "Enum", and has helper functions:<ul>
<li>static ENUM get_enum(const evo::SubString&amp; key):<ul>
<li>Map string key to ENUM value</li>
</ul>
</li>
<li>static SubString get_string(ENUM value):<ul>
<li>Map ENUM value to string key, null if unknown</li>
</ul>
</li>
</ul>
</li>
<li>This requires ENUM type to have the following value names defined, each name beginning with PREFIX:<ul>
<li>UNKNOWN &ndash; must be first</li>
<li>ENUM_END &ndash; must be last</li>
<li>and there <em>must not</em> be any gaps between the above values</li>
</ul>
</li>
<li><b>Caution:</b> The string values <em>must match ENUM and must be sorted</em></li>
<li>See example here: <a class="el" href="EnumConversion.html">Enum Conversion</a></li>
<li>See also: <a class="el" href="group___evo_containers.html#gab9e9898e6d31c9187eba0f588e348a5d" title="Helper for creating enum string/value mappers with explicit first/last/unknown values. ">EVO_ENUM_MAP()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create mappings for </td></tr>
    <tr><td class="paramname">PREFIX</td><td>Prefix for enum values, used to find UNKNOWN and ENUM_END values </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf72fd004c4fe4b7174f95db9a47e3d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_REMAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FIRST_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LAST_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">UNKNOWN_VAL, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">REMAP_ARRAY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>ENUM ## Enum { \</div><div class="line">        typedef ENUM Type; \</div><div class="line">        typedef EnumMapIterator&lt; ENUM ## Enum &gt; Iter; \</div><div class="line">        static <span class="keyword">const</span> ENUM FIRST   = FIRST_VAL; \</div><div class="line">        static <span class="keyword">const</span> ENUM LAST    = LAST_VAL; \</div><div class="line">        static <span class="keyword">const</span> ENUM UNKNOWN = UNKNOWN_VAL; \</div><div class="line">        static <span class="keyword">const</span> ENUM* get_remap_array() { \</div><div class="line">            return REMAP_ARRAY; \</div><div class="line">        } \</div><div class="line">        static <span class="keyword">const</span> <a class="code" href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">SizeT</a>* get_reverse_remap_array() { \</div><div class="line">            static <span class="keyword">const</span> SubStringMapList::ReverseRemap&lt; ENUM ## Enum &gt; REVERSE(get_remap_array()); \</div><div class="line">            return REVERSE.array; \</div><div class="line">        } \</div><div class="line">        static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a>&amp; map() { \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a> LIST[] = { __VA_ARGS__ }; \</div><div class="line">            static <span class="keyword">const</span> <a class="code" href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a> MAP(LIST, <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a>(LIST)); \</div><div class="line">            return MAP; \</div><div class="line">        } \</div><div class="line">        static ENUM get_enum(<span class="keyword">const</span> <a class="code" href="structevo_1_1_sub_string.html">evo::SubString</a>&amp; key) \</div><div class="line">            { <span class="keywordflow">return</span> map().find_enum_remap&lt;Type&gt;(get_remap_array(), key, FIRST, LAST, UNKNOWN); } \</div><div class="line">        static ENUM get_enum(<span class="keywordtype">int</span> val) \</div><div class="line">            { <span class="keywordflow">return</span> (val &lt; (<span class="keywordtype">int</span>)FIRST || val &gt; (<span class="keywordtype">int</span>)LAST ? UNKNOWN : (ENUM)val); } \</div><div class="line">        static <span class="keywordtype">int</span> get_int(ENUM val) \</div><div class="line">            { <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)val; } \</div><div class="line">        static SubString get_string(ENUM val) \</div><div class="line">            { <span class="keywordflow">return</span> map().get_enum_string_remap(get_reverse_remap_array(), val, FIRST, LAST); } \</div><div class="line">    }</div><div class="ttc" id="classevo_1_1_sub_string_map_list_html"><div class="ttname"><a href="classevo_1_1_sub_string_map_list.html">evo::SubStringMapList</a></div><div class="ttdoc">References a list of sorted substrings for fast lookup. </div><div class="ttdef"><b>Definition:</b> substring.h:1720</div></div>
<div class="ttc" id="group___evo_containers_html_ga633fe7675aa5dee3e6f52a017fe06530"><div class="ttname"><a href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">evo::fixed_array_size</a></div><div class="ttdeci">static uint fixed_array_size(T(&amp;)[sz])</div><div class="ttdoc">Get size of fixed-length array. </div><div class="ttdef"><b>Definition:</b> container.h:1104</div></div>
<div class="ttc" id="namespaceevo_html_acc6c0a7a5a715e4a53f0833762b25c7f"><div class="ttname"><a href="namespaceevo.html#acc6c0a7a5a715e4a53f0833762b25c7f">evo::SizeT</a></div><div class="ttdeci">uint32 SizeT</div><div class="ttdoc">Default Evo container size type. </div><div class="ttdef"><b>Definition:</b> sys.h:687</div></div>
<div class="ttc" id="structevo_1_1_sub_string_html"><div class="ttname"><a href="structevo_1_1_sub_string.html">evo::SubString</a></div><div class="ttdoc">Reference and access existing string data. </div><div class="ttdef"><b>Definition:</b> substring.h:227</div></div>
</div><!-- fragment -->
<p>Helper for creating enum string/value mappers with explicit first/last/unknown values, with unsorted enum remapped to sorted values. </p>
<ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>This is a variant of <a class="el" href="group___evo_containers.html#gab9e9898e6d31c9187eba0f588e348a5d" title="Helper for creating enum string/value mappers with explicit first/last/unknown values. ">EVO_ENUM_MAP()</a> for an unsorted enum</li>
<li>This uses <code>REMAP_ARRAY</code> to map an unsorted enum to sorted values &ndash; the data should be constant and static</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create traits for </td></tr>
    <tr><td class="paramname">FIRST_VAL</td><td>First enum value to map to, maps to first string </td></tr>
    <tr><td class="paramname">LAST_VAL</td><td>Last enum value to map to, maps to last string &ndash; must be &gt;= first_enum </td></tr>
    <tr><td class="paramname">UNKNOWN_VAL</td><td>Unknown enum value to use if key not found or result out of range </td></tr>
    <tr><td class="paramname">REMAP_ARRAY</td><td>Pointer to array of <code>ENUM</code> values sorted so they match the sorted string literals that follow </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace3a83429e05c602ce666b93bf865c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_ENUM_REMAP_PREFIXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ENUM, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PREFIX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">REMAP_ARRAY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___evo_containers.html#gaf72fd004c4fe4b7174f95db9a47e3d0f">EVO_ENUM_REMAP</a>(ENUM, (ENUM)((int)(PREFIX ## UNKNOWN) + 1), (ENUM)((int)(PREFIX ## ENUM_END) - 1), PREFIX ## UNKNOWN, REMAP_ARRAY, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for creating enum string/value mappers with prefixed enum values, with unsorted enum remapped to sorted values. </p>
<ul>
<li>#include &lt;<a class="el" href="enum_8h.html" title="Evo enum helpers. ">evo/enum.h</a>&gt;</li>
<li>This is a variant of <a class="el" href="group___evo_containers.html#ga74dbbe26bf9a19598be4726357e31e81" title="Helper for creating enum string/value mappers with prefixed enum values. ">EVO_ENUM_MAP_PREFIXED()</a> for an unsorted enum</li>
<li>This uses <code>REMAP_ARRAY</code> to map an unsorted enum to sorted values &ndash; the data should be constant and static</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ENUM</td><td>Enum type to create mappings for </td></tr>
    <tr><td class="paramname">PREFIX</td><td>Prefix for enum values, used to find UNKNOWN and ENUM_END values </td></tr>
    <tr><td class="paramname">REMAP_ARRAY</td><td>Pointer to array of <code>ENUM</code> values sorted so they match the sorted string literals that follow </td></tr>
    <tr><td class="paramname">...</td><td><em>Sorted</em> list of string literals to map to each enum value &ndash; ex: <code>"a", "b", "c"</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfe6bf882e790c50e3f95903729dcaf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_EXCEPTION_GUARD_END&#160;&#160;&#160;} catch (...) { abort(); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End exception guard, catch and abort(). </p>

</div>
</div>
<a class="anchor" id="gaefb0b1be8356978c929a7500037df949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_EXCEPTION_GUARD_START&#160;&#160;&#160;try {</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start exception guard (try block). </p>

</div>
</div>
<a class="anchor" id="ga402af8f7443cab5ca15eb9115f7355a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVO_FIXED_ARRAY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARRAY</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(evo::impl::FixedArraySizeHelper(ARRAY)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of fixed-length array at compile-time. </p>
<ul>
<li>Same as <a class="el" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530" title="Get size of fixed-length array. ">fixed_array_size()</a>, but resolves to a compile-time constant using sizeof() </li>
</ul>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga3a394eec1fb611abb2d9a6d54e65b796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BitArrayT BitArray</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default dynamic bit array container &ndash; see <a class="el" href="classevo_1_1_bit_array_t.html" title="Dynamic bit array container with similar interface to Array and List. ">BitArrayT</a>. </p>

</div>
</div>
<a class="anchor" id="ga9ad4c6636a2267a687c34cd00a6ab930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BitArraySubsetT&lt;BitArray&gt; BitArraySubset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default subset of a BitArray &ndash; see <a class="el" href="classevo_1_1_bit_array_subset_t.html" title="A subset of a BitArray. ">BitArraySubsetT</a>. </p>

</div>
</div>
<a class="anchor" id="ga185dac6c097eb183ddce255a5cb5c4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtFloatT&lt;float&gt; FmtFloat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format a floating pointer number. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_float_t.html" title="Explicitly format a floating pointer number. ">FmtFloatT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>, <a class="el" href="group___evo_containers.html#ga545d13254cd3cc232fbd30dc48d63152">FmtFloatD</a>, <a class="el" href="group___evo_containers.html#ga5513765313933e17b162b20dee1f1d86">FmtFloatL</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 01.230,4.56</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>(1.23, 3, 6) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; 4.56;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga545d13254cd3cc232fbd30dc48d63152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtFloatT&lt;double&gt; FmtFloatD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format a floating pointer number. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_float_t.html" title="Explicitly format a floating pointer number. ">FmtFloatT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>, <a class="el" href="group___evo_containers.html#ga545d13254cd3cc232fbd30dc48d63152">FmtFloatD</a>, <a class="el" href="group___evo_containers.html#ga5513765313933e17b162b20dee1f1d86">FmtFloatL</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 01.230,4.56</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>(1.23, 3, 6) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; 4.56;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga5513765313933e17b162b20dee1f1d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtFloatT&lt;ldouble&gt; FmtFloatL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format a floating pointer number. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_float_t.html" title="Explicitly format a floating pointer number. ">FmtFloatT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>, <a class="el" href="group___evo_containers.html#ga545d13254cd3cc232fbd30dc48d63152">FmtFloatD</a>, <a class="el" href="group___evo_containers.html#ga5513765313933e17b162b20dee1f1d86">FmtFloatL</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 01.230,4.56</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#ga185dac6c097eb183ddce255a5cb5c4c4">FmtFloat</a>(1.23, 3, 6) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; 4.56;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab11a4171455dc0fc86d7461af86ac5e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;int&gt; FmtInt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac8964dee24a784fe440b255aad52838f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;int16&gt; FmtInt16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8e57ecfe81770bde63a80428c7a8a62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;int32&gt; FmtInt32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4f59c175d16c2831d019b9030a10b28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;int64&gt; FmtInt64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad317e402a75ccba4dc59204a910f1b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;int8&gt; FmtInt8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga955eda15a9868f3f66e8f943d7196a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;long&gt; FmtLong</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabe4e13382160aebe0a0ff2863e28fa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;longl&gt; FmtLongL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gafcfe9402503bfc12694c9d1aadfb8abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;short&gt; FmtShort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7b19e8b7debda86abc7bb3b6d5a4dad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;uint&gt; FmtUInt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad35081c859ad442bda2b516bbf293e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;uint16&gt; FmtUInt16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga950e58f7503ea2025692eb07016e5326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;uint32&gt; FmtUInt32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad2fe152e7d1a710deea855ae6bbe53ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;uint64&gt; FmtUInt64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1b1f98e783ca0b4249bb8495d4f08821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;uint8&gt; FmtUInt8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad1b966ec807f8a29b516fdcd96c6fdbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;ulong&gt; FmtULong</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6556776dad40b74bf17707df78460590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;ulongl&gt; FmtULongL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga75c8e4d440603226b6d8b24c45e3d972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FmtIntT&lt;ushort&gt; FmtUShort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly format an integer. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, and <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a></li>
</ul>
</li>
<li>Don't use <a class="el" href="structevo_1_1_fmt_int_t.html" title="Explicitly format an integer. ">FmtIntT</a> directly, use one of the aliases:<ul>
<li><a class="el" href="group___evo_containers.html#gafcfe9402503bfc12694c9d1aadfb8abc">FmtShort</a>, <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>, <a class="el" href="group___evo_containers.html#ga955eda15a9868f3f66e8f943d7196a22">FmtLong</a>, <a class="el" href="group___evo_containers.html#gabe4e13382160aebe0a0ff2863e28fa9e">FmtLongL</a></li>
<li><a class="el" href="group___evo_containers.html#gad317e402a75ccba4dc59204a910f1b37">FmtInt8</a>, <a class="el" href="group___evo_containers.html#gac8964dee24a784fe440b255aad52838f">FmtInt16</a>, <a class="el" href="group___evo_containers.html#ga8e57ecfe81770bde63a80428c7a8a62b">FmtInt32</a>, <a class="el" href="group___evo_containers.html#ga4f59c175d16c2831d019b9030a10b28d">FmtInt64</a></li>
<li><a class="el" href="group___evo_containers.html#ga75c8e4d440603226b6d8b24c45e3d972">FmtUShort</a>, <a class="el" href="group___evo_containers.html#ga7b19e8b7debda86abc7bb3b6d5a4dad2">FmtUInt</a>, <a class="el" href="group___evo_containers.html#gad1b966ec807f8a29b516fdcd96c6fdbc">FmtULong</a>, <a class="el" href="group___evo_containers.html#ga6556776dad40b74bf17707df78460590">FmtULongL</a></li>
<li><a class="el" href="group___evo_containers.html#ga1b1f98e783ca0b4249bb8495d4f08821">FmtUInt8</a>, <a class="el" href="group___evo_containers.html#gad35081c859ad442bda2b516bbf293e41">FmtUInt16</a>, <a class="el" href="group___evo_containers.html#ga950e58f7503ea2025692eb07016e5326">FmtUInt32</a>, <a class="el" href="group___evo_containers.html#gad2fe152e7d1a710deea855ae6bbe53ba">FmtUInt64</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Example using <a class="el" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">evo/string.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Format string as: 07B,45,67</span></div><div class="line">    <a class="code" href="classevo_1_1_string.html">String</a> str;</div><div class="line">    str &lt;&lt; <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(123, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408">fHEX</a>, 3) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> <a class="code" href="group___evo_containers.html#gab11a4171455dc0fc86d7461af86ac5e0">FmtInt</a>(45, <a class="code" href="group___evo_containers.html#gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d">fDEC</a>) &lt;&lt; <span class="charliteral">&#39;,&#39;</span> 67;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga5951ce48779180c0473baae410bc80c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MapHash&lt;String,String&gt; StrHash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classevo_1_1_map_hash.html" title="Map implemented as a hash table. ">MapHash</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> keys and values. </p>
<ul>
<li>This is an alias to <a class="el" href="classevo_1_1_map_hash.html" title="Map implemented as a hash table. ">MapHash</a></li>
<li>This is only defined if <a class="el" href="string_8h.html" title="Evo String container. ">string.h</a> is included before <a class="el" href="maphash_8h.html" title="Evo MapHash container. ">maphash.h</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1dfc1ae73cc1f386b043ddd46326eda4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef String::ListBaseType StringBase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string typedef. </p>
<ul>
<li>Use to explicitly cast to a base string type<ul>
<li>Use on char* or STL string (if STL compatiblity enabled)</li>
<li>Not needed with string literals like: "test"</li>
</ul>
</li>
<li>This can solve compiler errors creating a temporary when "too many implicit conversions" are available<br />
 Example: <div class="fragment"><div class="line">std::string stdstr(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line"><a class="code" href="classevo_1_1_string.html">evo::String</a> str(<a class="code" href="group___evo_containers.html#ga1dfc1ae73cc1f386b043ddd46326eda4">StringBase</a>(stdstr));</div></div><!-- fragment --></li>
<li>See also: <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a></li>
</ul>

</div>
</div>
<a class="anchor" id="ga73d4f4ea3686689840d19597386b9776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MapList&lt;String,String&gt; StrMapList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classevo_1_1_map_list.html" title="Map implemented as an ordered list. ">MapList</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> keys and values. </p>
<ul>
<li>This is an alias to <a class="el" href="classevo_1_1_map_list.html" title="Map implemented as an ordered list. ">MapList</a></li>
<li>This is only defined if <a class="el" href="string_8h.html" title="Evo String container. ">string.h</a> is included before <a class="el" href="maplist_8h.html" title="Evo MapList container. ">maplist.h</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1e3e8cc2d9064c77f5464ec611388091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SetHash&lt;String&gt; StrSetHash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classevo_1_1_set_hash.html" title="Set implemented as a hash table. ">SetHash</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values. </p>
<ul>
<li>This is an alias to <a class="el" href="classevo_1_1_set_hash.html" title="Set implemented as a hash table. ">SetHash</a></li>
<li>This is only defined if <a class="el" href="string_8h.html" title="Evo String container. ">string.h</a> is included before <a class="el" href="sethash_8h.html" title="Evo SetHash container. ">sethash.h</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga0f1e9a01b59463183d19261ea54593b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SetList&lt;String&gt; StrSetList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classevo_1_1_set_list.html" title="Set implemented as an ordered sequential array/list. ">SetList</a> using <a class="el" href="classevo_1_1_string.html" title="String container. ">String</a> values. </p>
<ul>
<li>This is an alias to <a class="el" href="classevo_1_1_set_list.html" title="Set implemented as an ordered sequential array/list. ">SetList</a></li>
<li>This is only defined if <a class="el" href="string_8h.html" title="Evo String container. ">string.h</a> is included before <a class="el" href="setlist_8h.html" title="Evo SetList container. ">setlist.h</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga063daf12c7c0b1d1ae5d5194265a62e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Var VarList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classevo_1_1_var.html" title="General purpose variable that can hold a basic value (string, number, bool, etc) or children with nes...">Var</a>, useful for explicitly passing a list to a <a class="el" href="classevo_1_1_var_object.html" title="Explicit variant of Var used for initializing as an object with an initializer list of key/value pair...">VarObject</a> field value (C++11). </p>
<ul>
<li>Only use this with initializer lists &ndash; avoid defining a variable or parameter with this type</li>
<li>See <a class="el" href="classevo_1_1_var.html" title="General purpose variable that can hold a basic value (string, number, bool, etc) or children with nes...">Var</a> examples </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga558df9907996461d0b13492fd343c416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum CharBreakType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character break type returned by <a class="el" href="group___evo_containers.html#ga9331cc2f8106525f8cc7b2fe564011c0" title="Get ASCII character word-break type. ">ascii_breaktype()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416a81d1f058b27fcc397431a15ff200d257"></a>cbtOTHER&#160;</td><td class="fielddoc">
<p>Other charcater type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416a43dd2b9988fbff40074fbfd13ebb64f5"></a>cbtWSPACE&#160;</td><td class="fielddoc">
<p>Whitespace character, used between words. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416ac96c6ba66b4d1e6b1dcf9ffb570159c7"></a>cbtQUOTE&#160;</td><td class="fielddoc">
<p>Quote character, break word before or after this depending on whether begin or end quote ('"`) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416a67b3ec2d9f81f98b116b5b4b11ea3536"></a>cbtBEGIN&#160;</td><td class="fielddoc">
<p>Punctuation used before a word begins, break words before this ( ([{&lt; ) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416a80474ef81ff3391a8b0164940884b422"></a>cbtEND&#160;</td><td class="fielddoc">
<p>Punctuation used after a word ends, break words after this ( )]}&gt;!%;,./ ) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga558df9907996461d0b13492fd343c416a51eb02b324494131203ae8ffb8b92636"></a>cbtWORD&#160;</td><td class="fielddoc">
<p>Word character (A-Z, a-z, 0-9, _) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga29966b9994a4b4e8c250133a79f4a2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum CharType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character type returned by <a class="el" href="group___evo_containers.html#ga0bd0d06fab38d16c19beb13124c76b00" title="Get ASCII character type. ">ascii_type()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0abed84ee63ee7d297aa36bc97e7c773ac"></a>ctOTHER&#160;</td><td class="fielddoc">
<p>Other character type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0a07e50fdda5e47b27ed480590ab64fc7b"></a>ctWSPACE&#160;</td><td class="fielddoc">
<p>Whitespace character. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0aba32aa5b9440c88983117d783fb92366"></a>ctPUNCT&#160;</td><td class="fielddoc">
<p>Punctuation or symbol character. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0af683f76b5668d6f4bbf8b3c0267491d8"></a>ctDIGIT&#160;</td><td class="fielddoc">
<p>Numeric digit character (0-9) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0a56aba297544cc13a73ccbf2ce6d99148"></a>ctUPPER&#160;</td><td class="fielddoc">
<p>Uppercase alphabetic character (A-Z) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29966b9994a4b4e8c250133a79f4a2e0adf0fae83e0d51e1e3e5acc1c6d2339a7"></a>ctLOWER&#160;</td><td class="fielddoc">
<p>Lowercase alphabetic character (a-z) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga573874d977e2b22545076ff4c9e498b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum FmtAlign</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatting alignment. </p>
<ul>
<li>Used with <a class="el" href="structevo_1_1_fmt_set_field.html" title="Holds field and alignment formatting attributes. ">FmtSetField</a> and operator&lt;&lt;() on <a class="el" href="structevo_1_1_string_1_1_format.html" title="String formatter with state. ">String::Format</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, or <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga573874d977e2b22545076ff4c9e498b8a2276169c80f2b84eacc95e5d106b490e"></a>faCURRENT&#160;</td><td class="fielddoc">
<p>Current alignment (i.e. unspecified/default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga573874d977e2b22545076ff4c9e498b8abde979ec06a763810d6592fd9ffab4b1"></a>fLEFT&#160;</td><td class="fielddoc">
<p>Align left by adding filler on right side. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga573874d977e2b22545076ff4c9e498b8a8223960e6599779c962fa8a84c7599ff"></a>fCENTER&#160;</td><td class="fielddoc">
<p>Align center by adding filler on left and right sides. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga573874d977e2b22545076ff4c9e498b8a08921c0cd9efedb68d9987bac05757f7"></a>fRIGHT&#160;</td><td class="fielddoc">
<p>Align right by adding filler on left side. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga04e52ddd0c4be8a2754bbcfdf5bffe35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum FmtBase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatting integer base. </p>
<ul>
<li>Used with <a class="el" href="structevo_1_1_fmt_set_int.html" title="Holds integer formatting attributes. ">FmtSetInt</a> and operator&lt;&lt;() on <a class="el" href="structevo_1_1_string_1_1_format.html" title="String formatter with state. ">String::Format</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, or <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35a80de1dcbd5c7cf4e014902c37ecaf7d7"></a>fbCURRENT&#160;</td><td class="fielddoc">
<p>Current base (i.e. unspecified/default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35a0ebebc5fe5b2a70944fbc66dc43460db"></a>fbAUTO&#160;</td><td class="fielddoc">
<p>Auto base detection. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35a88653bddc3b0f17b1f4dde1e629739b7"></a>fBIN&#160;</td><td class="fielddoc">
<p>Base 2: binary. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35a685b13f40dbfac927e379fd66e0f9e23"></a>fOCT&#160;</td><td class="fielddoc">
<p>Base 8: octal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35a197444c2609d2c73b11df326e320d97d"></a>fDEC&#160;</td><td class="fielddoc">
<p>Base 10: decimal (default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35ad9f98700a736ef703f3f0ff73ae30408"></a>fHEX&#160;</td><td class="fielddoc">
<p>Base 16: hexadecimal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga04e52ddd0c4be8a2754bbcfdf5bffe35afebac51b4693152a1b5e843838b7dc94"></a>fHEXL&#160;</td><td class="fielddoc">
<p>Base 16: hexadecimal (lowercase) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5fe3009144f6921cb7e75b7b7bd50794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum FmtBasePrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatting integer base prefix type. </p>
<ul>
<li>Used with <a class="el" href="structevo_1_1_fmt_set_int.html" title="Holds integer formatting attributes. ">FmtSetInt</a> and operator&lt;&lt;() on <a class="el" href="structevo_1_1_string_1_1_format.html" title="String formatter with state. ">String::Format</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, or <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5fe3009144f6921cb7e75b7b7bd50794a5fc856c0f2df365518cfa36a8b16231a"></a>fbpCURRENT&#160;</td><td class="fielddoc">
<p>Current prefix (i.e. unspecified/default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5fe3009144f6921cb7e75b7b7bd50794ade051764b644fa6745ca356c4b556688"></a>fPREFIX0&#160;</td><td class="fielddoc">
<p>No base prefix (default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5fe3009144f6921cb7e75b7b7bd50794a4c4e49d7ff4f48545c13909ca6c50ddb"></a>fPREFIX1&#160;</td><td class="fielddoc">
<p>Single character base prefix (x for hex, o for octal, b for binary) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5fe3009144f6921cb7e75b7b7bd50794a666c28437a15a7c6f2fdef580575b1f6"></a>fPREFIX2&#160;</td><td class="fielddoc">
<p>Double character base prefix (0x for hex, 0o for octal, 0b for binary) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad9b7b29e9676f4002cbc9f8079c339fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum FmtPrecision</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatting floating point precision type. </p>
<ul>
<li>Used with <a class="el" href="structevo_1_1_fmt_set_float.html" title="Holds floating point formatting attributes. ">FmtSetFloat</a> and operator&lt;&lt;() on <a class="el" href="structevo_1_1_string_1_1_format.html" title="String formatter with state. ">String::Format</a>, <a class="el" href="classevo_1_1_stream.html" title="Input/Output stream implementation. ">Stream</a>, or <a class="el" href="classevo_1_1_stream_out.html" title="Output stream implementation. ">StreamOut</a> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea7af941d501c449527008e5034f9fef74"></a>fpCURRENT&#160;</td><td class="fielddoc">
<p>Current floating point precision (i.e. unspecified/default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339feae2ca8f83c6c0244b35d96b23eb0eb633"></a>fPREC_AUTO&#160;</td><td class="fielddoc">
<p>Automatic floating point precision &ndash; either normal decimal notation or E notation, whichever is shorter (default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea87279e40780f6c1c162bcbd9bddbb7dc"></a>fPREC0&#160;</td><td class="fielddoc">
<p>No floating point precision (whole numbers) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea7d22727f3dc1b21f15ffbba30816ac2e"></a>fPREC1&#160;</td><td class="fielddoc">
<p>1-digit floating point precision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fead4e92736684df38276daf8a50391e8cd"></a>fPREC2&#160;</td><td class="fielddoc">
<p>2-digit floating point precision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea9b9f37def2cd96072254821ae3b793d7"></a>fPREC3&#160;</td><td class="fielddoc">
<p>3-digit floating point precision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339feae83a06e260d39bcc7c2a4b8d90a58805"></a>fPREC4&#160;</td><td class="fielddoc">
<p>4-digit floating point precision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea74758ba0e567b7cea8437be9217bdab4"></a>fPREC5&#160;</td><td class="fielddoc">
<p>5-digit floating point precision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad9b7b29e9676f4002cbc9f8079c339fea225c52e0cb8b48e1394fe477e13cb533"></a>fPREC6&#160;</td><td class="fielddoc">
<p>6-digit floating point precision </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa7ad17c5e7e041c24796fdfcf86e03ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum FmtWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatting field width. </p>
<ul>
<li>Used with operator&lt;&lt;() on <a class="el" href="structevo_1_1_string_1_1_format.html" title="String formatter with state. ">String::Format</a> or <a class="el" href="classevo_1_1_stream.html#aa7b295828c2cb1f9d75d9000cc44b97e" title="Stream output formatter with state. ">Stream::Format</a><ul>
<li>See <a class="el" href="StringFormatting.html">String Formatting</a> and <a class="el" href="StreamFormatting.html">Stream Formatting</a> </li>
</ul>
</li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa7ad17c5e7e041c24796fdfcf86e03ecabbdbb4b24490f99b1a5a8e72deb96335"></a>fWIDTH0&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaaaf8b8c6f2e45d38c1e6be72cc3a066c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum IteratorDir</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator direction value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaaaf8b8c6f2e45d38c1e6be72cc3a066ca2076541f903f88f61fa9c14dfb4b6ef0"></a>iterNONE&#160;</td><td class="fielddoc">
<p>No iterator direction. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaaf8b8c6f2e45d38c1e6be72cc3a066cade6b4782743b684c938ae826329d1b0a"></a>iterFW&#160;</td><td class="fielddoc">
<p>Forward iterator direction. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaaf8b8c6f2e45d38c1e6be72cc3a066ca0b917fbd8a8a5db56105f5f499443eaf"></a>iterRV&#160;</td><td class="fielddoc">
<p>Reverse iterator direction. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8e8bed56091b38cec628d3aa8ce3f225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum IteratorPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator position value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8e8bed56091b38cec628d3aa8ce3f225aba95ce54f7de8cba91306c3325ba4ed5"></a>iterFIRST&#160;</td><td class="fielddoc">
<p>First item iterator position. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8e8bed56091b38cec628d3aa8ce3f225afa04bcd8bb52e56e9ffe697137527978"></a>iterLAST&#160;</td><td class="fielddoc">
<p>Last item iterator position. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8e8bed56091b38cec628d3aa8ce3f225ab80c386cac5dd30fb3dbc842dcf00e0b"></a>iterEND&#160;</td><td class="fielddoc">
<p>End iterator position. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga26a119b4837a0f787a2fc499fc5409b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum StringSearchAlg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String search algorithm selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga26a119b4837a0f787a2fc499fc5409b3a6ee5e8e291012c76f90cbaf0267c25d5"></a>ssaDEFAULT&#160;</td><td class="fielddoc">
<p>Default, uses system memmem() if possible (define EVO_NO_MEMMEM to prevent this), otherwise same as ssaKMP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga26a119b4837a0f787a2fc499fc5409b3af7647a8d0023f6c0e8223e9949293b10"></a>ssaKMP&#160;</td><td class="fielddoc">
<p>Knuth-Morris-Pratt using partial match table. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga26a119b4837a0f787a2fc499fc5409b3ae9c6bc5a5b6418deca7b9c60430c6a6e"></a>ssaBASIC&#160;</td><td class="fielddoc">
<p>Basic search using memchr() and memcmp() </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae9d2de7e838006cdc9643397de60a761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum UtfMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF decoding mode used to set how to handle invalid character values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b"></a>umINCLUDE_INVALID&#160;</td><td class="fielddoc">
<p>Include invalid characters &ndash; try to use as-is (dangerous) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e"></a>umREPLACE_INVALID&#160;</td><td class="fielddoc">
<p>Replace invalid characters with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9"></a>umSKIP_INVALID&#160;</td><td class="fielddoc">
<p>Skip invalid characters. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236"></a>umSTRICT&#160;</td><td class="fielddoc">
<p>Stop or error on invalid character. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9331cc2f8106525f8cc7b2fe564011c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharBreakType evo::ascii_breaktype </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ASCII character word-break type. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>This is used to help find a good place to insert a word-break</li>
<li>This recognizes standard ASCII codes 0-127</li>
<li>This does not use any locale information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character break type, see CharBreakType </dd></dl>

</div>
</div>
<a class="anchor" id="ga1940420bcd5613e0b46d3e6aa716cc84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char evo::ascii_tolower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ASCII character to lowercase. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>This recognizes standard ASCII codes 0-127</li>
<li>This does not use any locale information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted character </dd></dl>

</div>
</div>
<a class="anchor" id="gabb0c4eb6354d25b0603ce107e9ae347e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char evo::ascii_toupper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ASCII character to uppercase. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>This recognizes standard ASCII codes 0-127</li>
<li>This does not use any locale information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted character </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bd0d06fab38d16c19beb13124c76b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharType evo::ascii_type </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ASCII character type. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>This recognizes standard ASCII codes 0-127</li>
<li>This does not use any locale information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character type, see CharType </dd></dl>

</div>
</div>
<a class="anchor" id="ga633fe7675aa5dee3e6f52a017fe06530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint evo::fixed_array_size </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[sz]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of fixed-length array. </p>
<ul>
<li>Template params and result are inferred from argument type</li>
<li>This is often used with <a class="el" href="classevo_1_1_sub_string_map_list.html" title="References a list of sorted substrings for fast lookup. ">SubStringMapList</a></li>
<li>See also: <a class="el" href="group___evo_containers.html#ga402af8f7443cab5ca15eb9115f7355a6" title="Get size of fixed-length array at compile-time. ">EVO_FIXED_ARRAY_SIZE()</a></li>
</ul>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8h.html">evo/type.h</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevo.html">evo</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* STRLIST[] = {</div><div class="line">        <span class="stringliteral">&quot;one&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;two&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;three&quot;</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint size = <a class="code" href="group___evo_containers.html#ga633fe7675aa5dee3e6f52a017fe06530">fixed_array_size</a>(STRLIST);  <span class="comment">// set to 3</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6961c21def82a6c398beab677e0c84bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubString evo::lookupsub </td>
          <td>(</td>
          <td class="paramtype">const TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TMap::Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup (find) map value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> for given key. </p>
<ul>
<li>Useful helper for looking up any string value and converting via <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a><br />
 Example:<div class="fragment"><div class="line"><a class="code" href="group___evo_containers.html#ga73d4f4ea3686689840d19597386b9776">StrMapList</a> map;</div><div class="line">map[<span class="stringliteral">&quot;key&quot;</span>] = <span class="stringliteral">&quot;123&quot;</span>;</div><div class="line"><a class="code" href="group___evo_core.html#ga81e9aab92407bca0e62b6eb8da8ad463">Int</a> val = <a class="code" href="group___evo_containers.html#ga6961c21def82a6c398beab677e0c84bb">lookupsub</a>(map, <span class="stringliteral">&quot;key&quot;</span>).<a class="code" href="structevo_1_1_sub_string.html#acbd610d265c2582692e18c529f27bab6">num</a>(); <span class="comment">// val is null if key not found</span></div></div><!-- fragment --></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMap</td><td>Evo <a class="el" href="classevo_1_1_map.html" title="Associative container holding key/value pairs for fast lookup. ">Map</a> container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td><a class="el" href="classevo_1_1_map.html" title="Associative container holding key/value pairs for fast lookup. ">Map</a> to use </td></tr>
    <tr><td class="paramname">key</td><td>Key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a>, set to null if key not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914" title="Lookup (find) STL map value as SubString for given key. ">stdlookupsub()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0097d48e4f34c8a98a71c05867e933e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evo::map_contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether map contains key with matching value. </p>
<ul>
<li>This requires map value type to implement <code><a class="el" href="group___evo_thread.html#gaeb4d050d11155dab922dfaa934343914" title="Equality operator for managed pointer base and atomic pointer base. ">operator==()</a></code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Map type, inferred from arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Map to check </td></tr>
    <tr><td class="paramname">key</td><td>Key to check </td></tr>
    <tr><td class="paramname">value</td><td>Value to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether map contains key with matching value </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f47ce2762188e63861b2b6b51614ef0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evo::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_bit_array_subset_t.html">BitArraySubsetT</a>&lt; <a class="el" href="classevo_1_1_bit_array_t.html">BitArrayT</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_bit_array_t.html">BitArrayT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First subset to compare </td></tr>
    <tr><td class="paramname">b</td><td>Second subset to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether inequal </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fcb8fa4ea9227be274b204e9a07c318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evo::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_bit_array_subset_t.html">BitArraySubsetT</a>&lt; <a class="el" href="classevo_1_1_bit_array_t.html">BitArrayT</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_bit_array_t.html">BitArrayT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First subset to compare </td></tr>
    <tr><td class="paramname">b</td><td>Second subset to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether equal </dd></dl>

</div>
</div>
<a class="anchor" id="ga6172578257a7c375f20e923b29adeb95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TMap::mapped_type* evo::stdlookup </td>
          <td>(</td>
          <td class="paramtype">const TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TMap::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup (find) STL map value for given key (const). </p>
<ul>
<li>Useful for doing STL lookups without messing with STL iterators</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMap</td><td>STL map container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Map to use </td></tr>
    <tr><td class="paramname">key</td><td>Key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to found value, NULL if not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___evo_containers.html#gacef9f8c5fda1724c2b4294e34993f2f7" title="Lookup (find) STL map value for given key (mutable). ">stdlookupM()</a>, <a class="el" href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914" title="Lookup (find) STL map value as SubString for given key. ">stdlookupsub()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacef9f8c5fda1724c2b4294e34993f2f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TMap::mapped_type* evo::stdlookupM </td>
          <td>(</td>
          <td class="paramtype">TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TMap::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup (find) STL map value for given key (mutable). </p>
<ul>
<li>Useful for doing STL lookups without messing with STL iterators</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMap</td><td>STL map container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Map to use </td></tr>
    <tr><td class="paramname">key</td><td>Key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to found value, NULL if not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___evo_containers.html#ga6172578257a7c375f20e923b29adeb95" title="Lookup (find) STL map value for given key (const). ">stdlookup()</a>, <a class="el" href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914" title="Lookup (find) STL map value as SubString for given key. ">stdlookupsub()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga94d1ffc3283fda3d4f87ab26e3837914"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubString evo::stdlookupsub </td>
          <td>(</td>
          <td class="paramtype">const TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TMap::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup (find) STL map value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a> for given key. </p>
<ul>
<li>Useful helper for looking up any string value and converting via <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a><br />
 Example:<div class="fragment"><div class="line">std::map&lt;std::string,std::string&gt; map;</div><div class="line">map[<span class="stringliteral">&quot;key&quot;</span>] = <span class="stringliteral">&quot;123&quot;</span>;</div><div class="line"><a class="code" href="group___evo_core.html#ga81e9aab92407bca0e62b6eb8da8ad463">Int</a> val = <a class="code" href="group___evo_containers.html#ga94d1ffc3283fda3d4f87ab26e3837914">stdlookupsub</a>(map, <span class="stringliteral">&quot;key&quot;</span>).<a class="code" href="structevo_1_1_sub_string.html#acbd610d265c2582692e18c529f27bab6">num</a>(); <span class="comment">// val is null if key not found</span></div></div><!-- fragment --></li>
<li>Useful for doing STL lookups without messing with STL iterators</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMap</td><td>STL map container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Map to use </td></tr>
    <tr><td class="paramname">key</td><td>Key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found value as <a class="el" href="structevo_1_1_sub_string.html" title="Reference and access existing string data. ">SubString</a>, set to null if key not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___evo_containers.html#ga6961c21def82a6c398beab677e0c84bb" title="Lookup (find) map value as SubString for given key. ">lookupsub()</a>, <a class="el" href="group___evo_containers.html#ga6172578257a7c375f20e923b29adeb95" title="Lookup (find) STL map value for given key (const). ">stdlookup()</a>, <a class="el" href="group___evo_containers.html#gacef9f8c5fda1724c2b4294e34993f2f7" title="Lookup (find) STL map value for given key (mutable). ">stdlookupM()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga559960ce2025c5d1c7434e49c2631c30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evo::str_scan_backtickdel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string for a Backtick + DEL pair. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>A string is invalid text and is not quotable if it contains a backtick + DEL pair, and it contains all other quote types in a way that would confuse a parser</li>
<li>This is used by <a class="el" href="structevo_1_1_str_quoting.html#af3037bc0a260d669c663f5ce12013e9a">StrQuoting::get()</a> methods when falling back to <a class="el" href="structevo_1_1_str_quoting.html">tBACKTICK_DEL::tBACKTICK_DEL</a></li>
<li>See <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a backtick + DEL pair was found </dd></dl>

</div>
</div>
<a class="anchor" id="ga712ceba93c0e95af8764611c83f8484c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_decimal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for decimal number and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Stores parsed number (not reset to 0) [in/out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= str </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, end if whole string was scanned, NULL if invalid number or too many digits </dd></dl>

</div>
</div>
<a class="anchor" id="ga7af9672ca4ae539186fdcc796ab030e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_delim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim1</td><td>First delimiter to recognize </td></tr>
    <tr><td class="paramname">delim2</td><td>Second delimiter to recognize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="gad0d50640e5d8cb86df38e2ef6e21e37a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_delim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>delim_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>Note: SSE optimizations don't apply with <code>delim_count &gt; 16</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delims</td><td>Delimiters to scan for </td></tr>
    <tr><td class="paramname">delim_count</td><td>Number of delimiter to scan for, must not be 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bd1ba030b49a27b67198f6ae50dadfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_delim_r </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter in reverse and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a delimiter</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim1</td><td>First delimiter to recognize </td></tr>
    <tr><td class="paramname">delim2</td><td>Second delimiter to recognize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f1bf2d286b9fabe41740baa8d0292a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_delim_r </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>delim_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter in reverse and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a delimiter</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>Note: SSE optimizations don't apply with <code>delim_count &gt; 16</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delims</td><td>Delimiters to scan for </td></tr>
    <tr><td class="paramname">delim_count</td><td>Number of delimiter to scan for, must not be 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d987241324d938dbb488d309b1fa4c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer and extract quoted or unquoted text. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans for the end of the quoted value and sets out params accordingly</li>
<li><b>Caution:</b> This is dangerous if the input wasn't quoted <em>without</em> a delimiter in mind &ndash; see <a class="el" href="structevo_1_1_str_quoting.html#af3037bc0a260d669c663f5ce12013e9a">StrQuoting::get(const char*,ulong)</a><ul>
<li>See also: <a class="el" href="group___evo_containers.html#ga424e8d1bad91b18295caa7a3b424b08d" title="Scan string pointer and extract quoted or unquoted text with a delimiter. ">str_scan_endq(const char*&amp;,const char*&amp;,const char*,const char*,char)</a></li>
</ul>
</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned </dd></dl>

</div>
</div>
<a class="anchor" id="ga424e8d1bad91b18295caa7a3b424b08d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer and extract quoted or unquoted text with a delimiter. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans for the end of the quoted value and sets out params accordingly</li>
<li>The quoted value ends with an end-quote, followed by optional whitespace (space, tab, newlines), followed by a delim or end of input</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>See <a class="el" href="classevo_1_1_string.html#a02b44e74c69ea5f1d73cc241d279ea98" title="Write (append) quoted output to string. ">String::writequoted()</a>, <a class="el" href="structevo_1_1_str_quoting.html#af9b8dd5b7bbe000f13259f74ad068eb2">StrQuoting::get(bool&amp;,const char*,ulong,char)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars), same as <code>str</code> if unquoted [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter that ends the quoted text, may be a whitespace char (space, tab, newline) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this will point to a delim </dd></dl>

</div>
</div>
<a class="anchor" id="gad1d4d2e5cce221a47f26327e2fa3cd77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer and extract quoted or unquoted text with 2 possible delimiters. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans for the end of the quoted value and sets out params accordingly</li>
<li>The quoted value ends with an end-quote, followed by optional whitespace (space, tab, newlines), followed by either delim or end of input</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>See <a class="el" href="classevo_1_1_string.html#a02b44e74c69ea5f1d73cc241d279ea98" title="Write (append) quoted output to string. ">String::writequoted()</a>, StrQuoting::get(bool&amp;,const char*,ulong,char,char)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim1</td><td>Delimiter that may end the quoted text, must not be a whitespace character (space, tab, newline) </td></tr>
    <tr><td class="paramname">delim2</td><td>Another delimiter that may end the quoted text, must not be a whitespace character (space, tab, newline) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this will point to a delim </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7824467a59d7aee8612dfd7e74ee760"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>delim_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ws_delim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer and extract quoted or unquoted text with multiple possible delimiters. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans for the end of the quoted value and sets out params accordingly</li>
<li>The quoted value ends with an end-quote, followed by optional whitespace (space, tab, newlines), followed by either a delim or end of input</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>Note: SSE optimizations don't apply with <code>delim_count &gt; 16</code></li>
<li>See <a class="el" href="classevo_1_1_string.html#a02b44e74c69ea5f1d73cc241d279ea98" title="Write (append) quoted output to string. ">String::writequoted()</a>, StrQuoting::get(bool&amp;,const char*,ulong,char,char)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delims</td><td>Delimiters that may end the quoted text, if this contains a whitespace char (space, tab, newline) then <code>ws_delim</code> must be set too &ndash; more than 1 whitespace delimiter is not supported </td></tr>
    <tr><td class="paramname">delim_count</td><td>Number of delimiters in <code>delims</code>, must be greater than 0 </td></tr>
    <tr><td class="paramname">ws_delim</td><td>Use to specify a whitespace delimiter in <code>delims</code>, 0 if no whitespace delim &ndash; this is used to handle whitespace correctly between an end-quote and a delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this will point to a delim </dd></dl>

</div>
</div>
<a class="anchor" id="ga259128db4798e6c8d377ffb25668c9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq_r </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer in reverse and extract quoted or unquoted text with a delimiter and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans in reverse (i.e. right to left):<ul>
<li>This scans for the beginning of the quoted value and sets out params accordingly</li>
<li>The quoted value begins with an end-quote, preceded by optional whitespace (space, tab, newlines), preceded by a delim or end of input</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a delimiter</li>
</ul>
</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>See <a class="el" href="classevo_1_1_string.html#a02b44e74c69ea5f1d73cc241d279ea98" title="Write (append) quoted output to string. ">String::writequoted()</a>, <a class="el" href="structevo_1_1_str_quoting.html#af9b8dd5b7bbe000f13259f74ad068eb2">StrQuoting::get(bool&amp;,const char*,ulong,char)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars), same as <code>end</code> if unquoted [out] </td></tr>
    <tr><td class="paramname">str</td><td>String beginning pointer to stop scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to start scanning in reverse, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter that ends the quoted text, may be a whitespace char (space, tab, newline) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="ga9be2483cee503b8ae406e7f1b7c14432"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_endq_r </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>startq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>endq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>delim_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ws_delim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer in reverse and extract quoted or unquoted text with multiple possible delimiters and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This scans in reverse (i.e. right to left):<ul>
<li>This scans for the beginning of the quoted value and sets out params accordingly</li>
<li>The quoted value begins with an end-quote, preceded by optional whitespace (space, tab, newlines), preceded by a delim or end of input</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a delimiter</li>
</ul>
</li>
<li>This supports all the Evo quoting types &ndash; see <a class="el" href="SmartQuoting.html">Smart Quoting</a></li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
<li>Note: SSE optimizations don't apply with <code>delim_count &gt; 16</code></li>
<li>See <a class="el" href="classevo_1_1_string.html#a02b44e74c69ea5f1d73cc241d279ea98" title="Write (append) quoted output to string. ">String::writequoted()</a>, <a class="el" href="structevo_1_1_str_quoting.html#af9b8dd5b7bbe000f13259f74ad068eb2">StrQuoting::get(bool&amp;,const char*,ulong,char)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startq</td><td>Set to start of quoted text (without quote chars) [out] </td></tr>
    <tr><td class="paramname">endq</td><td>Set to end of quoted text (without quote chars), same as <code>end</code> if unquoted [out] </td></tr>
    <tr><td class="paramname">str</td><td>String beginning pointer to stop scan, must not be null </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to start scanning in reverse, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delims</td><td>Delimiters that may end the quoted text, if this contains a whitespace char (space, tab, newline) then <code>ws_delim</code> must be set too &ndash; more than 1 whitespace delimiter is not supported </td></tr>
    <tr><td class="paramname">delim_count</td><td>Number of delimiters in <code>delims</code>, must be greater than 0 </td></tr>
    <tr><td class="paramname">ws_delim</td><td>Use to specify a whitespace delimiter in <code>delims</code>, 0 if no whitespace delim &ndash; this is used to handle whitespace correctly between an end-quote and a delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="ga227636a7c9549757d059948b4a2543dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_hex </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for hex number and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Stores parsed number (not reset to 0) [in/out] </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= str </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, end if whole string was scanned, NULL if invalid number or too many digits </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e971eb1c263d72a704a493621d8b1e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_ndelim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next non-delimiter and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim1</td><td>First delimiter to recognize </td></tr>
    <tr><td class="paramname">delim2</td><td>Second delimiter to recognize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next non-delimiter character </dd></dl>

</div>
</div>
<a class="anchor" id="ga4be60ca2f9faf381f7a2cbab9d949c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_ndelim_r </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next non-delimiter in reverse and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a non-delimiter</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim1</td><td>First delimiter to recognize </td></tr>
    <tr><td class="paramname">delim2</td><td>Second delimiter to recognize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a non-delimiter </dd></dl>

</div>
</div>
<a class="anchor" id="gab5799401683473661a8fd1362508c6f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_nws </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next non-whitespace character and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next non-whitespace character </dd></dl>

</div>
</div>
<a class="anchor" id="gac4fb88707879c77dbbf50cad558d101e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_nws </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter or non-whitespace character and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This is similar to <a class="el" href="group___evo_containers.html#gab5799401683473661a8fd1362508c6f9" title="Scan string pointer for next non-whitespace character and return stop pointer. ">str_scan_nws(const char*,const char*)</a> but also works when <code>delim</code> is itself a whitespace character</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to stop at, which may be a whitespace character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next non-whitespace character </dd></dl>

</div>
</div>
<a class="anchor" id="ga67034d1c3b7bc59a8041f6fe74949127"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_nws_r </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next non-whitespace character in reverse and return new end after stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This returns a new <code>end</code> pointer, which points to the character <em>after</em> a non-whitespace</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>End pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New end pointer, <code>str</code> if whole string was scanned, otherwise this points to the <em>next char after</em> a non-whitespace character </dd></dl>

</div>
</div>
<a class="anchor" id="gad271596747e9b82677a1c9c110353668"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_nws_r </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for next delimiter or non-whitespace character and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This is similar to <a class="el" href="group___evo_containers.html#gab5799401683473661a8fd1362508c6f9" title="Scan string pointer for next non-whitespace character and return stop pointer. ">str_scan_nws(const char*,const char*)</a> but also works when <code>delim</code> is itself a whitespace character</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter to stop at, which may be a whitespace character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, otherwise this points to the next non-whitespace character </dd></dl>

</div>
</div>
<a class="anchor" id="ga2364b09ca1b3814c3ee45a39934f3456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_to </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for char and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlen</td><td>Max allowed length to scan before returning an error, ignored if 0 </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= str </td></tr>
    <tr><td class="paramname">ch</td><td>Char to scan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, NULL if <code>maxlen</code> exceeded and <code>ch</code> not found within <code>maxlen</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0c26a278301a1078074257c00d15374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::str_scan_to </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan string pointer for either of 2 chars and return stop pointer. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt;</li>
<li>This uses SSE optimization when enabled &ndash; see <a class="el" href="CppCompilers.html">C++ Compilers &amp; Optimization</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlen</td><td>Max allowed length to scan before returning an error, ignored if 0 </td></tr>
    <tr><td class="paramname">str</td><td>String pointer to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop scanning, must be &gt;= str </td></tr>
    <tr><td class="paramname">ch1</td><td>First char to scan for </td></tr>
    <tr><td class="paramname">ch2</td><td>Second char to scan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stop pointer, <code>end</code> if whole string was scanned, NULL if maxlen exceeded </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e4931e8d7dec87ad316cb11f2d2f6dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::string_memrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evo implementation of memrchr() to search for character in reverse. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>This searches for a character in reverse and returns a pointer to it, or <code>NULL</code> if not found</li>
<li>This calls <code>memrchr()</code> (GNU C extension) when possible, otherwise this falls back to an equivalent implementation</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String pointer to search </td></tr>
    <tr><td class="paramname">ch</td><td>Character to search for </td></tr>
    <tr><td class="paramname">size</td><td>String size to search, search starts at the end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to last occurence of <code>ch</code>, NULL if not found </dd></dl>

</div>
</div>
<a class="anchor" id="ga74613d1a4da699a72378124e9c4d415a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two non-terminated UTF-16 strings. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also terminated variants: <a class="el" href="group___evo_containers.html#gac5280554190c9effb26dafacc9636bc2" title="Compare a non-terminated UTF-16 string with a terminated UTF-16 string. ">utf16_compare(const wchar16*,ulong,const wchar16*)</a>, <a class="el" href="group___evo_containers.html#ga6338569f372bc94c75e87b2ac2853133" title="Compare two terminated UTF-16 strings. ">utf16_compare(const wchar16*,const wchar16*)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len2</td><td>Second string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="gac5280554190c9effb26dafacc9636bc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a non-terminated UTF-16 string with a terminated UTF-16 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated variant: <a class="el" href="group___evo_containers.html#ga74613d1a4da699a72378124e9c4d415a" title="Compare two non-terminated UTF-16 strings. ">utf16_compare(const wchar16*,ulong,const wchar16*,ulong)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6338569f372bc94c75e87b2ac2853133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two terminated UTF-16 strings. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated variant: <a class="el" href="group___evo_containers.html#ga74613d1a4da699a72378124e9c4d415a" title="Compare two non-terminated UTF-16 strings. ">utf16_compare(const wchar16*,ulong,const wchar16*,ulong)</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must be terminated, must not be NULL </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga833d6bcd2b8682b226b049ed3842f6f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare8 </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a non-terminated UTF-16 string to a non-terminated UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also terminated variants: utf16_compare(const wchar16*,ulong,const char*), utf16_compare(const wchar16*,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len2</td><td>Second string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a638442adea48b28e8dfd1464beb80f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare8 </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a non-terminated UTF-16 string to a terminated UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated and terminated variants: utf16_compare(const wchar16*,ulong,const char*,ulong), utf16_compare(const wchar16*,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must not be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ef49877387b9318aad8a35bf4ea87d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf16_compare8 </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a terminated UTF-16 string to a terminated UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated variants: utf16_compare(const wchar16*,ulong,const char*,ulong), utf16_compare(const wchar16*,ulong,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must be terminated, must not be NULL </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga92b43536760d88299f94b813aa2d12d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong evo::utf16_count </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count Unicode character values in UTF-16 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Each UTF-16 character may span 1 or 2 16-bit values (2 or 4 bytes), depending on the character<ul>
<li>2 byte values are the raw Unicode 16-bit code value</li>
<li>4 byte values are pairs of reserved 16-bit values called surrogate pairs</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-16 values:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-16 values are counted as 1 character each</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-16 values are counted as 1 character each (<a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a>)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-16 values are skipped and not counted</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop counting on invalid UTF-16 value and return an error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Unicode characters counted, NONE on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e56577dae084dd79781bb646f4e9806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar16* evo::utf16_min </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mincount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for UTF-16 surrogate pairs, which each require a pair of wchar16 values (4 bytes). </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Surrogate pairs are used for Unicode code points 0x10000 to 0x10FFFF, which are less common</li>
<li>Valid UTF-16 without surrogate pairs is also valid UCS-2 (a precursor to UTF-16)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string to search, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">strict</td><td>Whether to stop counting on invalid UTF-16 value, false to skip/ignore invalid UTF-16 values </td></tr>
    <tr><td class="paramname">mincount</td><td>Minimum number of surrogate pairs to look for, must be positive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to UTF-16 character that met mincount, NULL if less than <code>mincount</code> surrogate pairs found </dd></dl>

</div>
</div>
<a class="anchor" id="ga9742b1c299ff73b16b1f37c7c7c3a6c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar16* evo::utf16_scan </td>
          <td>(</td>
          <td class="paramtype">wchar32 &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for next Unicode character in UTF-16 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>A UTF-16 character may span 1 or 2 16-bit values (2 or 4 bytes), depending on the character<ul>
<li>2 byte values are the raw Unicode 16-bit code value</li>
<li>4 byte values are pairs of reserved 16-bit values called surrogate pairs</li>
</ul>
</li>
<li>Call this in a loop to iterate through Unicode characters in a UTF-16 string, stop when NULL is returned</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> to full Unicode character code scanned, or error code on error (see return value) [out] </td></tr>
    <tr><td class="paramname">str</td><td>Pointer to string to scan, must not be ULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-16 values:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-16 values are each returned as-is (1 character each)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-16 bytes are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-16 values are skipped (ignored)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop with error on invalid UTF-16 value, return NULL and set code=1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after scanned Unicode character, NULL with code=0 if stopped at end of string, NULL with code=1 on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b9f49b0f69d0749993baf0ba6dbcdf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar16* evo::utf16_scan_term </td>
          <td>(</td>
          <td class="paramtype">wchar32 &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for next Unicode character in terminated UTF-16 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>A UTF-16 character may span 1 or 2 16-bit values (2 or 4 bytes), depending on the character<ul>
<li>2 byte values are the raw Unicode 16-bit code value</li>
<li>4 byte values are pairs of reserved 16-bit values called surrogate pairs</li>
</ul>
</li>
<li>Call this in a loop to iterate through Unicode characters in a terminated UTF-16 string, stop when NULL is returned</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> to full Unicode character code scanned, or error code on error (see return value) [out] </td></tr>
    <tr><td class="paramname">str</td><td>Pointer to string to scan, muts be terminated, must not be ULL </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-16 values:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-16 values are each returned as-is (1 character each)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-16 bytes are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-16 values are skipped (ignored)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop with error on invalid UTF-16 value, return NULL and set code=1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after scanned Unicode character, NULL with code=0 if stopped at end of string, NULL with code=1 on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f1b4e33cb99a4f3d286f8192f7f6ce0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong evo::utf16_strlen </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find terminated UTF-16 string length. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string, must be NULL terminated, NULL for none </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String length in UTF-16 values (not bytes), 0 if str=NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dbf51b006c81323205810e32e8add70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong evo::utf16_to8 </td>
          <td>(</td>
          <td class="paramtype">const wchar16 *&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar16 *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outbuf</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>outsize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UTF-16 string to UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to input UTF-16 string to convert, set to stopping point on return, must not be NULL [in/out] </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop input at (end of input, exclusive), must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">outbuf</td><td>Output buffer to write UTF-8 string to, NULL to scan without writing </td></tr>
    <tr><td class="paramname">outsize</td><td>Output buffer size in bytes, ignored if outbuf=NULL </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-16 values:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-16 values are converted as-is (1 character each)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-16 values are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-16 values are skipped and ignored</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop on invalid input with an error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count written to outbuf in bytes, END on invalid input (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga30cd7d72857428ef143e31487681857f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf8_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two non-terminated UTF-8 strings. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also terminated variants: <a class="el" href="group___evo_containers.html#ga888b93d184e26c70d1413f638286e133" title="Compare non-terminated and terminated UTF-8 strings. ">utf8_compare(const char*,ulong,const char*)</a>, utf16_compare(const char*,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, can be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, can be NULL </td></tr>
    <tr><td class="paramname">len2</td><td>Second string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga888b93d184e26c70d1413f638286e133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf8_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare non-terminated and terminated UTF-8 strings. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated and terminated variants: <a class="el" href="group___evo_containers.html#ga30cd7d72857428ef143e31487681857f" title="Compare two non-terminated UTF-8 strings. ">utf8_compare(const char*,ulong,const char*,ulong)</a>, utf16_compare(const char*,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, can be NULL </td></tr>
    <tr><td class="paramname">len1</td><td>First string length </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="ga08d3926c1e241f6c91caef16fda2e115"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int evo::utf8_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two terminated UTF-8 strings. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>See also non-terminated variants: <a class="el" href="group___evo_containers.html#ga30cd7d72857428ef143e31487681857f" title="Compare two non-terminated UTF-8 strings. ">utf8_compare(const char*,ulong,const char*,ulong)</a>, utf16_compare(const char*,ulong,const char*)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>First string to compare, must be terminated, can be NULL </td></tr>
    <tr><td class="paramname">str2</td><td>Second string to compare, must be terminated, can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a class="anchor" id="gaa49e468722a9f3152ec1eda12b9c1c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong evo::utf8_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count Unicode character values in UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Each UTF-8 character may span 1-4 bytes, depending on the character</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-8 bytes:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-8 values are counted as 1 character each</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-8 values are counted as 1 character each (<a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a>)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-8 values are skipped and not counted</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop counting on an invalid UTF-8 value and return an error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Unicode characters counted, NONE on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga41bfd5eac7a114cced29fa66e8796561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::utf8_min </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>mincount</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>minsize</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for UTF-8 multi-byte characters of at least minsize. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Multi-byte characters are used for higher Unicode code points</li>
<li>Valid UTF-8 single-byte characters are also valid ASCII characters</li>
<li>Use <code>minsize</code> to set the multi-byte characters to stop at &ndash; character sizes smaller than this are ignored</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string to search, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">strict</td><td>Whether to stop counting on invalid UTF-8 byte, false to skip/ignore invalid UTF-8 bytes </td></tr>
    <tr><td class="paramname">mincount</td><td>Minimum number of multi-byte values to look for, must be positive </td></tr>
    <tr><td class="paramname">minsize</td><td>Minimum number of bytes to count as multi-byte value, must be 2-4 (inclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to UTF-8 character that met mincount, NULL if not enough multi-byte values found </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f664abecc08952b89e03c285b0f180c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::utf8_scan </td>
          <td>(</td>
          <td class="paramtype">wchar32 &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for next Unicode character in UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Each UTF-8 character may span 1-4 bytes, depending on the character</li>
<li>Call this in a loop to iterate through Unicode characters in a UTF-8 string, stop when NULL is returned</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> to full Unicode character code scanned, or error code on error (see return value) [out] </td></tr>
    <tr><td class="paramname">str</td><td>Pointer to string to scan, must not be NULL </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to end of string to scan, must be &gt;= <code>str</code> </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-8 bytes:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-8 bytes are each used as-is (1 byte each)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-8 bytes are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-8 values are skipped (ignored)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop with error on invalid UTF-8 value, return NULL and set code=1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after scanned Unicode character, NULL with code=0 if stopped at end of string, NULL with code=1 on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga21e46ab59bced3ecab5a31031ed5e000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* evo::utf8_scan_term </td>
          <td>(</td>
          <td class="paramtype">wchar32 &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for next Unicode character in terminated UTF-8 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt;</li>
<li>Each UTF-8 character may span 1-4 bytes, depending on the character</li>
<li>Call this in a loop to iterate through Unicode characters in a UTF-8 string, stop when NULL is returned</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><a class="el" href="classevo_1_1_set.html" title="Associative container with unique values for fast lookup. ">Set</a> to full Unicode character code scanned, or error code on error (see return value) [out] </td></tr>
    <tr><td class="paramname">str</td><td>Pointer to string to scan, must be terminated, must not be NULL </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-8 bytes:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-8 bytes are each used as-is (1 byte each)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-8 bytes are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid UTF-8 values are skipped (ignored)</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop with error on invalid UTF-8 value, return NULL and set code=1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after scanned Unicode character, NULL with code=0 if stopped at end of string, NULL with code=1 on error (if mode=umSTRICT) </dd></dl>

</div>
</div>
<a class="anchor" id="ga70c8368370a8c3c8e4f4a8f251292608"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong evo::utf8_to16 </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar16 *&#160;</td>
          <td class="paramname"><em>outbuf</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>outsize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___evo_containers.html#gae9d2de7e838006cdc9643397de60a761">UtfMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UTF-8 string to UTF-16 string. </p>
<ul>
<li>#include &lt;<a class="el" href="strscan_8h.html" title="Evo string scanning helpers with SSE optimized code. ">evo/strscan.h</a>&gt; or &lt;<a class="el" href="string_8h.html" title="Evo String container. ">evo/string.h</a>&gt; or &lt;<a class="el" href="substring_8h.html" title="Evo SubString container. ">evo/substring.h</a>&gt; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to input UTF-8 string to convert, set to stopping point on return, must not be NULL [in/out] </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to stop input at (end of input, exclusive) </td></tr>
    <tr><td class="paramname">outbuf</td><td>Output buffer to write UTF-16 string to, NULL to scan without writing </td></tr>
    <tr><td class="paramname">outsize</td><td>Output buffer size as wchar16 count (not bytes), ignored if outbuf=NULL </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle invalid UTF-8 bytes and values that convert to reserved UTF-16 surrogate values:<ul>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a5a16664b145b5498dd213c5fb6d26a0b">umINCLUDE_INVALID</a> - Invalid UTF-8 bytes are still converted, but invalid UTF-16 surrogate values that can't be represented are skipped</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a4835e00e93c76bb689d37414c88da72e">umREPLACE_INVALID</a> - Invalid UTF-8 bytes are each replaced with <a class="el" href="group___evo_containers.html#ga62f7c1d38790be092e1afa04b0586f58">UNICODE_REPLACEMENT_CHAR</a></li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761a7feeeb794123ce153fc678186f82acd9">umSKIP_INVALID</a> - Invalid input is skipped and ignored</li>
<li><a class="el" href="group___evo_containers.html#ggae9d2de7e838006cdc9643397de60a761ae17260310509f5a1aee11d847e060236">umSTRICT</a> - Stop on invalid input with an error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count written to outbuf as wchar16 count (not bytes), END on invalid input (if mode=umSTRICT) </dd></dl>
</li>
</ul>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga62f7c1d38790be092e1afa04b0586f58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar16 UNICODE_REPLACEMENT_CHAR = 0xFFFD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unicode code point for "Replacement Character" used when decoding invalid UTF bytes or values. </p>
<ul>
<li>This character often shows as a question mark in a box</li>
<li>Unicode code point: FFFD</li>
<li>UTF-8: Encoded with 3 bytes as 0xEF 0xBF 0xBD</li>
<li>UTF-16 &amp; UTF-32: Encoded directly as 0xFFFD </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2019 22:50:50 for Evo C++ Library v0.5 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
