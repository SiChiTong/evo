<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Evo C++ Library v0.5.1: PtrList&lt; T, TSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evo C++ Library v0.5.1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceevo.html">evo</a></li><li class="navelem"><a class="el" href="classevo_1_1_ptr_list.html">PtrList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classevo_1_1_ptr_list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PtrList&lt; T, TSize &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___evo_containers.html">EvoContainers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ptrlist_8h_source.html">evo/ptrlist.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class TSize = SizeT&gt;<br />
class evo::PtrList&lt; T, TSize &gt;</h3>

<p>Sequential list of managed pointers with random access. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to use &ndash; an item type will be <code>T*</code> (<code>Item</code>), a pointer to items type will be <code>T**</code> (<code>Item*</code>) </td></tr>
    <tr><td class="paramname">TSize</td><td>Size type to use for size/index values (must be unsigned integer) &ndash; default: SizeT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Features</dt><dd></dd></dl>
<ul>
<li>This is similar to <a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a> but is specialized to hold an array of managed pointers, with <a class="el" href="classevo_1_1_ptr_list.html" title="Sequential list of managed pointers with random access. ">PtrList</a>:<ul>
<li><a class="el" href="_sharing.html">Sharing</a> (without external references) is supported, but <a class="el" href="_slicing.html">Slicing</a> is not supported</li>
<li>The size and capacity of the list are the same &ndash; no extra capacity is allocated for adding new items</li>
<li>The size is the number of items allocated, any of which may be null</li>
<li>Item pointers are automatically freed (if not NULL)</li>
<li>Iterators skip null items and only return non-null items</li>
</ul>
</li>
<li>Some methods have a read-only (const) version and mutable version with suffix "M" &ndash; example: <a class="el" href="classevo_1_1_ptr_list.html#a0c776383302f9c1d6c28678849f17d89" title="Get item at position (const). ">item()</a> and <a class="el" href="classevo_1_1_ptr_list.html#a0ece36cd56ac4e9e81c382aaeb6bfad8" title="Get item at position (mutable). ">itemM()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ac9a09ad8db07d71a9d15d4f7920e99ce" title="Get item at position (const). ">operator[]()</a> is read-only &ndash; use <a class="el" href="classevo_1_1_ptr_list.html#a14e2fe286c8d433180b4884e0e957d10" title="Get item at position (mutable). ">operator()()</a> or <a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec" title="Get item value for key, creating if needed (mutable). ">get()</a> for mutable access</li>
<li>Create items with <a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec" title="Get item value for key, creating if needed (mutable). ">get()</a></li>
<li>Supports <a class="el" href="_sharing.html">Sharing</a> &ndash; however immutable data will be copied</li>
</ul>
<p>C++11:</p><ul>
<li>Range-based for loop &ndash; see <a class="el" href="_stl_compatibility.html">STL Compatibility</a> <div class="fragment"><div class="line">PtrList&lt;int&gt; list;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> num : list.asconst()) {</div><div class="line">}</div></div><!-- fragment --></li>
<li>Initialization lists <div class="fragment"><div class="line">PtrList&lt;int&gt; list = {1, 2, 3};</div></div><!-- fragment --></li>
<li>Move semantics</li>
</ul>
<dl class="section user"><dt>Iterators</dt><dd></dd></dl>
<ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e" title="Iterator (const) - IteratorRa. ">PtrList&lt;&gt;::Iter</a> &ndash; Read-Only Iterator (<a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>)</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6" title="Iterator (mutable) - IteratorRa. ">PtrList&lt;&gt;::IterM</a> &ndash; Mutable Iterator (<a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>)</li>
</ul>
<dl class="section user"><dt>Constructors</dt><dd></dd></dl>
<ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a41c11cb9cb53fc91c22c4eddfb8a2013" title="Default constructor sets as null. ">PtrList()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#aebf3f9ee565da6a2f1190449fafee499" title="Copy constructor. ">PtrList(const ThisType&amp;)</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a9d1f30ad617e3158d3509caec69999dd" title="Sequence constructor (C++11). ">PtrList(std::initializer_list&lt;T&gt;)</a> [C++11]</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#abe326d8a32e961db68f7dbfd83df689f" title="Move constructor (C++11). ">PtrList(ThisType&amp;&amp;)</a> [C++11]</li>
</ul>
<dl class="section user"><dt>Read Access</dt><dd></dd></dl>
<ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#acce0ab2cacc475b2434f24c65c91685a" title="Get list size. ">size()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a5fc3ccc049f9327dc84116f44bde5c26" title="Get whether null. ">null()</a>, <a class="el" href="classevo_1_1_ptr_list.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Get whether empty. ">empty()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#acb3e912f111aeca639e8ca31a63ad5ec" title="Get whether shared. ">shared()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125" title="Get data pointer for direct access (const). ">data()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a0c776383302f9c1d6c28678849f17d89" title="Get item at position (const). ">item()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ac9a09ad8db07d71a9d15d4f7920e99ce" title="Get item at position (const). ">operator[]()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a7db168fe0a939de2cd0dca14eaaf49ca" title="Get first non-null item (const). ">first()</a>, <a class="el" href="classevo_1_1_ptr_list.html#a676580448265761be440acc7aeff1954" title="Get last non-null item (const). ">last()</a>, <a class="el" href="classevo_1_1_ptr_list.html#ad80a61d0d69ea6a2b996492cf2259917" title="Get index for last item position using offset. ">iend()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ae5cf100657e66fe9b53235efea0c7710" title="Comparison. ">compare()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#ae3e876e0fa5f273131cda34e2083743b" title="Equality operator. ">operator==()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ade9e807f7f885259f9ba23798808dbe9" title="Inequality operator. ">operator!=()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef" title="Get iterator at end (const). ">cend()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a5ba0fc6e8555617fd28b156f3b428093" title="Get iterator at first item (const). ">begin() const</a>, <a class="el" href="classevo_1_1_ptr_list.html#ad2cae394a7c7691f05878ed4ca9f001b" title="Get iterator at end (const). ">end() const</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a13d5f20caa825eef1823584895ad3b2c" title="Find first occurrence of item with forward search. ">find()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a13054f08a6851a8faf26d6fb4fe45886" title="Find last occurrence of item with reverse search. ">findr()</a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Modifiers</dt><dd></dd></dl>
<ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a59fabf379a400b94b3933f360a58c02c" title="Get data pointer (mutable). ">dataM()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#a0ece36cd56ac4e9e81c382aaeb6bfad8" title="Get item at position (mutable). ">itemM()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a14e2fe286c8d433180b4884e0e957d10" title="Get item at position (mutable). ">operator()()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#acd53910745ebf588026065177b8229c0" title="Get iterator at first item (mutable). ">begin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf" title="Get iterator at end. ">end()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe" title="Resize while preserving existing data (modifier). ">resize()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#ab17cabe5df6f4c4216e5676e08593d43" title="Resize to minimum size while preserving existing data (modifier). ">resizemin()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a219a41ab8fb6246ea2bc13678191cc79" title="Set as null and empty. ">set()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#aec9a049e8455daa831bd28ebf1e93558" title="Set from another list. ">set(const ThisType&amp;)</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ae48db32319ac5d88b4da288304f50efe" title="Set as empty but not null. ">setempty()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a0a255b9041ed57db4f1f25adf917dc0f" title="Clear by removing all items. ">clear()</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ae6c82138bee897766f29d30eec053a81" title="Assignment operator. ">operator=(const ThisType&amp;)</a></li>
<li><a class="el" href="classevo_1_1_ptr_list.html#af1b94f01d07c02f63bdba2b782732674" title="Move assignment operator (C++11). ">operator=(ThisType&amp;&amp;)</a> [C++11]</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a7da3137afbe1f1068ac1104f132b09b1" title="Set as full (unshared) copy using data pointer (modifier). ">copy(const ThisType&amp;)</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec" title="Get item value for key, creating if needed (mutable). ">get()</a><ul>
<li><a class="el" href="classevo_1_1_ptr_list.html#ad723d39c44b7064a6be92369e755c818" title="Get item for key, creating if needed (mutable). ">getitem()</a></li>
</ul>
</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#a6e5b3a8116984dc3f19ad9bc9d9c1616" title="Remove item and set as null (modifier). ">remove()</a></li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevo_1_1_ptr_list_1_1_header.html">Header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a> data header.  <a href="structevo_1_1_ptr_list_1_1_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a37141ed300dc2d966fce0b311f83f7ca"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a37141ed300dc2d966fce0b311f83f7ca">EvoContainerType</a></td></tr>
<tr class="separator:a37141ed300dc2d966fce0b311f83f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f5c9d036735eb0f28040842847a38"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a></td></tr>
<tr class="memdesc:a919f5c9d036735eb0f28040842847a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item type (pointer to Value)  <a href="#a919f5c9d036735eb0f28040842847a38">More...</a><br /></td></tr>
<tr class="separator:a919f5c9d036735eb0f28040842847a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d22e6961fb9ba9899db498fd226d4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classevo_1_1_iterator_ra.html">IteratorRa</a>&lt; <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &gt;::Const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a></td></tr>
<tr class="memdesc:a77d22e6961fb9ba9899db498fd226d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator (const) - <a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>.  <a href="#a77d22e6961fb9ba9899db498fd226d4e">More...</a><br /></td></tr>
<tr class="separator:a77d22e6961fb9ba9899db498fd226d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532d87f518998bf5e0007aa207aa5ec6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classevo_1_1_iterator_ra.html">IteratorRa</a>&lt; <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a></td></tr>
<tr class="memdesc:a532d87f518998bf5e0007aa207aa5ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator (mutable) - <a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>.  <a href="#a532d87f518998bf5e0007aa207aa5ec6">More...</a><br /></td></tr>
<tr class="separator:a532d87f518998bf5e0007aa207aa5ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042bda8b98e14936d8741ace1bd3b954"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a></td></tr>
<tr class="memdesc:a042bda8b98e14936d8741ace1bd3b954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type (item index)  <a href="#a042bda8b98e14936d8741ace1bd3b954">More...</a><br /></td></tr>
<tr class="separator:a042bda8b98e14936d8741ace1bd3b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480de157f9f73b69befd00d0545dd70"><td class="memItemLeft" align="right" valign="top">typedef TSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a></td></tr>
<tr class="memdesc:a6480de157f9f73b69befd00d0545dd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">List size integer type  <a href="#a6480de157f9f73b69befd00d0545dd70">More...</a><br /></td></tr>
<tr class="separator:a6480de157f9f73b69befd00d0545dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a35c554ff33fcf76b537a78429f45df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classevo_1_1_ptr_list.html">PtrList</a>&lt; T, <a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a></td></tr>
<tr class="memdesc:a8a35c554ff33fcf76b537a78429f45df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This list type.  <a href="#a8a35c554ff33fcf76b537a78429f45df">More...</a><br /></td></tr>
<tr class="separator:a8a35c554ff33fcf76b537a78429f45df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b57a974fe67a997b7693e6e71cd904"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a></td></tr>
<tr class="memdesc:a34b57a974fe67a997b7693e6e71cd904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type (Item dereferenced, same as T)  <a href="#a34b57a974fe67a997b7693e6e71cd904">More...</a><br /></td></tr>
<tr class="separator:a34b57a974fe67a997b7693e6e71cd904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41c11cb9cb53fc91c22c4eddfb8a2013"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a41c11cb9cb53fc91c22c4eddfb8a2013">PtrList</a> ()</td></tr>
<tr class="memdesc:a41c11cb9cb53fc91c22c4eddfb8a2013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor sets as null.  <a href="#a41c11cb9cb53fc91c22c4eddfb8a2013">More...</a><br /></td></tr>
<tr class="separator:a41c11cb9cb53fc91c22c4eddfb8a2013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf3f9ee565da6a2f1190449fafee499"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#aebf3f9ee565da6a2f1190449fafee499">PtrList</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>)</td></tr>
<tr class="memdesc:aebf3f9ee565da6a2f1190449fafee499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aebf3f9ee565da6a2f1190449fafee499">More...</a><br /></td></tr>
<tr class="separator:aebf3f9ee565da6a2f1190449fafee499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1f30ad617e3158d3509caec69999dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a9d1f30ad617e3158d3509caec69999dd">PtrList</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a9d1f30ad617e3158d3509caec69999dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence constructor (C++11).  <a href="#a9d1f30ad617e3158d3509caec69999dd">More...</a><br /></td></tr>
<tr class="separator:a9d1f30ad617e3158d3509caec69999dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe326d8a32e961db68f7dbfd83df689f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#abe326d8a32e961db68f7dbfd83df689f">PtrList</a> (<a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:abe326d8a32e961db68f7dbfd83df689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (C++11).  <a href="#abe326d8a32e961db68f7dbfd83df689f">More...</a><br /></td></tr>
<tr class="separator:abe326d8a32e961db68f7dbfd83df689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07aeea46f95c2fee76bc7fc0e26f14f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ac07aeea46f95c2fee76bc7fc0e26f14f">~PtrList</a> ()</td></tr>
<tr class="memdesc:ac07aeea46f95c2fee76bc7fc0e26f14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac07aeea46f95c2fee76bc7fc0e26f14f">More...</a><br /></td></tr>
<tr class="separator:ac07aeea46f95c2fee76bc7fc0e26f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c13702156198367fc9a8776f6beb38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a40c13702156198367fc9a8776f6beb38">asconst</a> () const</td></tr>
<tr class="memdesc:a40c13702156198367fc9a8776f6beb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly use a const reference to this.  <a href="#a40c13702156198367fc9a8776f6beb38">More...</a><br /></td></tr>
<tr class="separator:a40c13702156198367fc9a8776f6beb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53910745ebf588026065177b8229c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#acd53910745ebf588026065177b8229c0">begin</a> ()</td></tr>
<tr class="memdesc:acd53910745ebf588026065177b8229c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at first item (mutable).  <a href="#acd53910745ebf588026065177b8229c0">More...</a><br /></td></tr>
<tr class="separator:acd53910745ebf588026065177b8229c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0fc6e8555617fd28b156f3b428093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a5ba0fc6e8555617fd28b156f3b428093">begin</a> () const</td></tr>
<tr class="memdesc:a5ba0fc6e8555617fd28b156f3b428093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at first item (const).  <a href="#a5ba0fc6e8555617fd28b156f3b428093">More...</a><br /></td></tr>
<tr class="separator:a5ba0fc6e8555617fd28b156f3b428093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac489717f3b69c08171c3e96001c346d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1">cbegin</a> () const</td></tr>
<tr class="memdesc:ac489717f3b69c08171c3e96001c346d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at first item (const).  <a href="#ac489717f3b69c08171c3e96001c346d1">More...</a><br /></td></tr>
<tr class="separator:ac489717f3b69c08171c3e96001c346d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b61c5914f98f93750fdd0e86b48cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef">cend</a> () const</td></tr>
<tr class="memdesc:aa1b61c5914f98f93750fdd0e86b48cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at end (const).  <a href="#aa1b61c5914f98f93750fdd0e86b48cef">More...</a><br /></td></tr>
<tr class="separator:aa1b61c5914f98f93750fdd0e86b48cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a255b9041ed57db4f1f25adf917dc0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a0a255b9041ed57db4f1f25adf917dc0f">clear</a> ()</td></tr>
<tr class="memdesc:a0a255b9041ed57db4f1f25adf917dc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear by removing all items.  <a href="#a0a255b9041ed57db4f1f25adf917dc0f">More...</a><br /></td></tr>
<tr class="separator:a0a255b9041ed57db4f1f25adf917dc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cf100657e66fe9b53235efea0c7710"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ae5cf100657e66fe9b53235efea0c7710">compare</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>) const</td></tr>
<tr class="memdesc:ae5cf100657e66fe9b53235efea0c7710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison.  <a href="#ae5cf100657e66fe9b53235efea0c7710">More...</a><br /></td></tr>
<tr class="separator:ae5cf100657e66fe9b53235efea0c7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da3137afbe1f1068ac1104f132b09b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a7da3137afbe1f1068ac1104f132b09b1">copy</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>)</td></tr>
<tr class="memdesc:a7da3137afbe1f1068ac1104f132b09b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set as full (unshared) copy using data pointer (modifier).  <a href="#a7da3137afbe1f1068ac1104f132b09b1">More...</a><br /></td></tr>
<tr class="separator:a7da3137afbe1f1068ac1104f132b09b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff284a10e589857e1612356637d5d125"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a> () const</td></tr>
<tr class="memdesc:aff284a10e589857e1612356637d5d125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data pointer for direct access (const).  <a href="#aff284a10e589857e1612356637d5d125">More...</a><br /></td></tr>
<tr class="separator:aff284a10e589857e1612356637d5d125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fabf379a400b94b3933f360a58c02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a59fabf379a400b94b3933f360a58c02c">dataM</a> ()</td></tr>
<tr class="memdesc:a59fabf379a400b94b3933f360a58c02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data pointer (mutable).  <a href="#a59fabf379a400b94b3933f360a58c02c">More...</a><br /></td></tr>
<tr class="separator:a59fabf379a400b94b3933f360a58c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether empty.  <a href="#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87e8d6522dbd627eb106867c5e3facf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf">end</a> ()</td></tr>
<tr class="memdesc:aa87e8d6522dbd627eb106867c5e3facf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at end.  <a href="#aa87e8d6522dbd627eb106867c5e3facf">More...</a><br /></td></tr>
<tr class="separator:aa87e8d6522dbd627eb106867c5e3facf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cae394a7c7691f05878ed4ca9f001b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ad2cae394a7c7691f05878ed4ca9f001b">end</a> () const</td></tr>
<tr class="memdesc:ad2cae394a7c7691f05878ed4ca9f001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator at end (const).  <a href="#ad2cae394a7c7691f05878ed4ca9f001b">More...</a><br /></td></tr>
<tr class="separator:ad2cae394a7c7691f05878ed4ca9f001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d5f20caa825eef1823584895ad3b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a13d5f20caa825eef1823584895ad3b2c">find</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a> &amp;value, <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> start=0, <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf">end</a>=<a class="el" href="group___evo_core.html#ga72f5a71bcf1f982c309cc4410a01ba81">END</a>) const</td></tr>
<tr class="memdesc:a13d5f20caa825eef1823584895ad3b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of item with forward search.  <a href="#a13d5f20caa825eef1823584895ad3b2c">More...</a><br /></td></tr>
<tr class="separator:a13d5f20caa825eef1823584895ad3b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13054f08a6851a8faf26d6fb4fe45886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a13054f08a6851a8faf26d6fb4fe45886">findr</a> (const T &amp;value, <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> start=0, <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf">end</a>=<a class="el" href="group___evo_core.html#ga72f5a71bcf1f982c309cc4410a01ba81">END</a>) const</td></tr>
<tr class="memdesc:a13054f08a6851a8faf26d6fb4fe45886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurrence of item with reverse search.  <a href="#a13054f08a6851a8faf26d6fb4fe45886">More...</a><br /></td></tr>
<tr class="separator:a13054f08a6851a8faf26d6fb4fe45886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db168fe0a939de2cd0dca14eaaf49ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a7db168fe0a939de2cd0dca14eaaf49ca">first</a> () const</td></tr>
<tr class="memdesc:a7db168fe0a939de2cd0dca14eaaf49ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first non-null item (const).  <a href="#a7db168fe0a939de2cd0dca14eaaf49ca">More...</a><br /></td></tr>
<tr class="separator:a7db168fe0a939de2cd0dca14eaaf49ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d1dc5a5ca1d5a78e11de3ad36c3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec">get</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> &amp;key, bool *created=NULL)</td></tr>
<tr class="memdesc:ae67d1dc5a5ca1d5a78e11de3ad36c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item value for key, creating if needed (mutable).  <a href="#ae67d1dc5a5ca1d5a78e11de3ad36c3ec">More...</a><br /></td></tr>
<tr class="separator:ae67d1dc5a5ca1d5a78e11de3ad36c3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad723d39c44b7064a6be92369e755c818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ad723d39c44b7064a6be92369e755c818">getitem</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> &amp;key, bool *created=NULL)</td></tr>
<tr class="memdesc:ad723d39c44b7064a6be92369e755c818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item for key, creating if needed (mutable).  <a href="#ad723d39c44b7064a6be92369e755c818">More...</a><br /></td></tr>
<tr class="separator:ad723d39c44b7064a6be92369e755c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a61d0d69ea6a2b996492cf2259917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ad80a61d0d69ea6a2b996492cf2259917">iend</a> (<a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> offset=0) const</td></tr>
<tr class="memdesc:ad80a61d0d69ea6a2b996492cf2259917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index for last item position using offset.  <a href="#ad80a61d0d69ea6a2b996492cf2259917">More...</a><br /></td></tr>
<tr class="separator:ad80a61d0d69ea6a2b996492cf2259917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c776383302f9c1d6c28678849f17d89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a0c776383302f9c1d6c28678849f17d89">item</a> (<a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> index) const</td></tr>
<tr class="memdesc:a0c776383302f9c1d6c28678849f17d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at position (const).  <a href="#a0c776383302f9c1d6c28678849f17d89">More...</a><br /></td></tr>
<tr class="separator:a0c776383302f9c1d6c28678849f17d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ece36cd56ac4e9e81c382aaeb6bfad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a0ece36cd56ac4e9e81c382aaeb6bfad8">itemM</a> (<a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> index)</td></tr>
<tr class="memdesc:a0ece36cd56ac4e9e81c382aaeb6bfad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at position (mutable).  <a href="#a0ece36cd56ac4e9e81c382aaeb6bfad8">More...</a><br /></td></tr>
<tr class="separator:a0ece36cd56ac4e9e81c382aaeb6bfad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676580448265761be440acc7aeff1954"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a676580448265761be440acc7aeff1954">last</a> () const</td></tr>
<tr class="memdesc:a676580448265761be440acc7aeff1954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last non-null item (const).  <a href="#a676580448265761be440acc7aeff1954">More...</a><br /></td></tr>
<tr class="separator:a676580448265761be440acc7aeff1954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc3ccc049f9327dc84116f44bde5c26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a5fc3ccc049f9327dc84116f44bde5c26">null</a> () const</td></tr>
<tr class="memdesc:a5fc3ccc049f9327dc84116f44bde5c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether null.  <a href="#a5fc3ccc049f9327dc84116f44bde5c26">More...</a><br /></td></tr>
<tr class="separator:a5fc3ccc049f9327dc84116f44bde5c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9e807f7f885259f9ba23798808dbe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ade9e807f7f885259f9ba23798808dbe9">operator!=</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>) const</td></tr>
<tr class="memdesc:ade9e807f7f885259f9ba23798808dbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#ade9e807f7f885259f9ba23798808dbe9">More...</a><br /></td></tr>
<tr class="separator:ade9e807f7f885259f9ba23798808dbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e2fe286c8d433180b4884e0e957d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a14e2fe286c8d433180b4884e0e957d10">operator()</a> (<a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> index)</td></tr>
<tr class="memdesc:a14e2fe286c8d433180b4884e0e957d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at position (mutable).  <a href="#a14e2fe286c8d433180b4884e0e957d10">More...</a><br /></td></tr>
<tr class="separator:a14e2fe286c8d433180b4884e0e957d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b94f01d07c02f63bdba2b782732674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#af1b94f01d07c02f63bdba2b782732674">operator=</a> (<a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:af1b94f01d07c02f63bdba2b782732674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator (C++11).  <a href="#af1b94f01d07c02f63bdba2b782732674">More...</a><br /></td></tr>
<tr class="separator:af1b94f01d07c02f63bdba2b782732674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c82138bee897766f29d30eec053a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ae6c82138bee897766f29d30eec053a81">operator=</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>)</td></tr>
<tr class="memdesc:ae6c82138bee897766f29d30eec053a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae6c82138bee897766f29d30eec053a81">More...</a><br /></td></tr>
<tr class="separator:ae6c82138bee897766f29d30eec053a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e876e0fa5f273131cda34e2083743b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ae3e876e0fa5f273131cda34e2083743b">operator==</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>) const</td></tr>
<tr class="memdesc:ae3e876e0fa5f273131cda34e2083743b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#ae3e876e0fa5f273131cda34e2083743b">More...</a><br /></td></tr>
<tr class="separator:ae3e876e0fa5f273131cda34e2083743b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a09ad8db07d71a9d15d4f7920e99ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ac9a09ad8db07d71a9d15d4f7920e99ce">operator[]</a> (<a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> index) const</td></tr>
<tr class="memdesc:ac9a09ad8db07d71a9d15d4f7920e99ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at position (const).  <a href="#ac9a09ad8db07d71a9d15d4f7920e99ce">More...</a><br /></td></tr>
<tr class="separator:ac9a09ad8db07d71a9d15d4f7920e99ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5b3a8116984dc3f19ad9bc9d9c1616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a6e5b3a8116984dc3f19ad9bc9d9c1616">remove</a> (<a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> key)</td></tr>
<tr class="memdesc:a6e5b3a8116984dc3f19ad9bc9d9c1616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove item and set as null (modifier).  <a href="#a6e5b3a8116984dc3f19ad9bc9d9c1616">More...</a><br /></td></tr>
<tr class="separator:a6e5b3a8116984dc3f19ad9bc9d9c1616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e90947ff4c0b0a10ad2e42373f6ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe">resize</a> (<a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> newsize)</td></tr>
<tr class="memdesc:a10e90947ff4c0b0a10ad2e42373f6ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize while preserving existing data (modifier).  <a href="#a10e90947ff4c0b0a10ad2e42373f6ebe">More...</a><br /></td></tr>
<tr class="separator:a10e90947ff4c0b0a10ad2e42373f6ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17cabe5df6f4c4216e5676e08593d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ab17cabe5df6f4c4216e5676e08593d43">resizemin</a> (<a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> minsize)</td></tr>
<tr class="memdesc:ab17cabe5df6f4c4216e5676e08593d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize to minimum size while preserving existing data (modifier).  <a href="#ab17cabe5df6f4c4216e5676e08593d43">More...</a><br /></td></tr>
<tr class="separator:ab17cabe5df6f4c4216e5676e08593d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219a41ab8fb6246ea2bc13678191cc79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a219a41ab8fb6246ea2bc13678191cc79">set</a> ()</td></tr>
<tr class="memdesc:a219a41ab8fb6246ea2bc13678191cc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set as null and empty.  <a href="#a219a41ab8fb6246ea2bc13678191cc79">More...</a><br /></td></tr>
<tr class="separator:a219a41ab8fb6246ea2bc13678191cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9a049e8455daa831bd28ebf1e93558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#aec9a049e8455daa831bd28ebf1e93558">set</a> (const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;<a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125">data</a>)</td></tr>
<tr class="memdesc:aec9a049e8455daa831bd28ebf1e93558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from another list.  <a href="#aec9a049e8455daa831bd28ebf1e93558">More...</a><br /></td></tr>
<tr class="separator:aec9a049e8455daa831bd28ebf1e93558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48db32319ac5d88b4da288304f50efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ae48db32319ac5d88b4da288304f50efe">setempty</a> ()</td></tr>
<tr class="memdesc:ae48db32319ac5d88b4da288304f50efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set as empty but not null.  <a href="#ae48db32319ac5d88b4da288304f50efe">More...</a><br /></td></tr>
<tr class="separator:ae48db32319ac5d88b4da288304f50efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e912f111aeca639e8ca31a63ad5ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#acb3e912f111aeca639e8ca31a63ad5ec">shared</a> () const</td></tr>
<tr class="memdesc:acb3e912f111aeca639e8ca31a63ad5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether shared.  <a href="#acb3e912f111aeca639e8ca31a63ad5ec">More...</a><br /></td></tr>
<tr class="separator:acb3e912f111aeca639e8ca31a63ad5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce0ab2cacc475b2434f24c65c91685a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#acce0ab2cacc475b2434f24c65c91685a">size</a> () const</td></tr>
<tr class="memdesc:acce0ab2cacc475b2434f24c65c91685a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list size.  <a href="#acce0ab2cacc475b2434f24c65c91685a">More...</a><br /></td></tr>
<tr class="separator:acce0ab2cacc475b2434f24c65c91685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3584c7b7893bbc584668a9d5be81c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a6d3584c7b7893bbc584668a9d5be81c7">swap</a> (<a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;list)</td></tr>
<tr class="memdesc:a6d3584c7b7893bbc584668a9d5be81c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another list.  <a href="#a6d3584c7b7893bbc584668a9d5be81c7">More...</a><br /></td></tr>
<tr class="separator:a6d3584c7b7893bbc584668a9d5be81c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b133eb243fa5845996a312890eeb305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305">unshare</a> ()</td></tr>
<tr class="memdesc:a0b133eb243fa5845996a312890eeb305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure data is not shared by allocating new buffer if needed (modifier).  <a href="#a0b133eb243fa5845996a312890eeb305">More...</a><br /></td></tr>
<tr class="separator:a0b133eb243fa5845996a312890eeb305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4820f826e79735c2e056b8e810dcac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a6a4820f826e79735c2e056b8e810dcac">used</a> () const</td></tr>
<tr class="memdesc:a6a4820f826e79735c2e056b8e810dcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list used size, number of non-null items.  <a href="#a6a4820f826e79735c2e056b8e810dcac">More...</a><br /></td></tr>
<tr class="separator:a6a4820f826e79735c2e056b8e810dcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a053cc96ea6f4a88d23c99fd7b4eb73e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#a053cc96ea6f4a88d23c99fd7b4eb73e6">data_</a></td></tr>
<tr class="memdesc:a053cc96ea6f4a88d23c99fd7b4eb73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data pointer, NULL if null, can be 1 if empty (size_=0)  <a href="#a053cc96ea6f4a88d23c99fd7b4eb73e6">More...</a><br /></td></tr>
<tr class="separator:a053cc96ea6f4a88d23c99fd7b4eb73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27da035d0d3c1313bae9f65d2e3c145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevo_1_1_ptr_list_1_1_header.html">Header</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#ab27da035d0d3c1313bae9f65d2e3c145">header_</a></td></tr>
<tr class="memdesc:ab27da035d0d3c1313bae9f65d2e3c145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data header pointer, NULL if no buffer allocated.  <a href="#ab27da035d0d3c1313bae9f65d2e3c145">More...</a><br /></td></tr>
<tr class="separator:ab27da035d0d3c1313bae9f65d2e3c145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af413506ef7c7376c1ea8ca4622cb1ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevo_1_1_ptr_list.html#af413506ef7c7376c1ea8ca4622cb1ada">size_</a></td></tr>
<tr class="memdesc:af413506ef7c7376c1ea8ca4622cb1ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data size (same as header.size), 0 if empty.  <a href="#af413506ef7c7376c1ea8ca4622cb1ada">More...</a><br /></td></tr>
<tr class="separator:af413506ef7c7376c1ea8ca4622cb1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a37141ed300dc2d966fce0b311f83f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37141ed300dc2d966fce0b311f83f7ca">&#9670;&nbsp;</a></span>EvoContainerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="classevo_1_1_ptr_list.html#a37141ed300dc2d966fce0b311f83f7ca">EvoContainerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a919f5c9d036735eb0f28040842847a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f5c9d036735eb0f28040842847a38">&#9670;&nbsp;</a></span>Item</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Item type (pointer to Value) </p>

</div>
</div>
<a id="a77d22e6961fb9ba9899db498fd226d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d22e6961fb9ba9899db498fd226d4e">&#9670;&nbsp;</a></span>Iter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classevo_1_1_iterator_ra.html">IteratorRa</a>&lt;<a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&gt;::Const <a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator (const) - <a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>. </p>

</div>
</div>
<a id="a532d87f518998bf5e0007aa207aa5ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532d87f518998bf5e0007aa207aa5ec6">&#9670;&nbsp;</a></span>IterM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classevo_1_1_iterator_ra.html">IteratorRa</a>&lt;<a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&gt; <a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator (mutable) - <a class="el" href="classevo_1_1_iterator_ra.html" title="Random access iterator. ">IteratorRa</a>. </p>

</div>
</div>
<a id="a042bda8b98e14936d8741ace1bd3b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042bda8b98e14936d8741ace1bd3b954">&#9670;&nbsp;</a></span>Key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key type (item index) </p>

</div>
</div>
<a id="a6480de157f9f73b69befd00d0545dd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480de157f9f73b69befd00d0545dd70">&#9670;&nbsp;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TSize <a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List size integer type </p>

</div>
</div>
<a id="a8a35c554ff33fcf76b537a78429f45df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a35c554ff33fcf76b537a78429f45df">&#9670;&nbsp;</a></span>ThisType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classevo_1_1_ptr_list.html">PtrList</a>&lt;T,<a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&gt; <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This list type. </p>

</div>
</div>
<a id="a34b57a974fe67a997b7693e6e71cd904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b57a974fe67a997b7693e6e71cd904">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type (Item dereferenced, same as T) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41c11cb9cb53fc91c22c4eddfb8a2013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c11cb9cb53fc91c22c4eddfb8a2013">&#9670;&nbsp;</a></span>PtrList() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html">PtrList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor sets as null. </p>

</div>
</div>
<a id="aebf3f9ee565da6a2f1190449fafee499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf3f9ee565da6a2f1190449fafee499">&#9670;&nbsp;</a></span>PtrList() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html">PtrList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<ul>
<li>Makes shared copy if possible &ndash; see <a class="el" href="_sharing.html">Sharing</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac07aeea46f95c2fee76bc7fc0e26f14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07aeea46f95c2fee76bc7fc0e26f14f">&#9670;&nbsp;</a></span>~PtrList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classevo_1_1_ptr_list.html">PtrList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a9d1f30ad617e3158d3509caec69999dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1f30ad617e3158d3509caec69999dd">&#9670;&nbsp;</a></span>PtrList() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html">PtrList</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequence constructor (C++11). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list, passed as comma-separated values in braces <code>{ }</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe326d8a32e961db68f7dbfd83df689f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe326d8a32e961db68f7dbfd83df689f">&#9670;&nbsp;</a></span>PtrList() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html">PtrList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor (C++11). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a40c13702156198367fc9a8776f6beb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c13702156198367fc9a8776f6beb38">&#9670;&nbsp;</a></span>asconst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; asconst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly use a const reference to this. </p>
<ul>
<li>This is useful to force using this as const without casting</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="acd53910745ebf588026065177b8229c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd53910745ebf588026065177b8229c0">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at first item (mutable). </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
<li><a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a> is more efficient, since this effectively calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a> to make items mutable</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at first item, or at end position if empty </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6" title="Iterator (mutable) - IteratorRa. ">IterM</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf" title="Get iterator at end. ">end()</a>, <a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef" title="Get iterator at end (const). ">cend()</a> </dd></dl>

</div>
</div>
<a id="a5ba0fc6e8555617fd28b156f3b428093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0fc6e8555617fd28b156f3b428093">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at first item (const). </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at first item, or at end position if empty </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#ad2cae394a7c7691f05878ed4ca9f001b" title="Get iterator at end (const). ">end() const</a>, <a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a> </dd></dl>

</div>
</div>
<a id="ac489717f3b69c08171c3e96001c346d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac489717f3b69c08171c3e96001c346d1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a> cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at first item (const). </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at first item, or at end position if empty </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e" title="Iterator (const) - IteratorRa. ">Iter</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef" title="Get iterator at end (const). ">cend()</a>, <a class="el" href="classevo_1_1_ptr_list.html#acd53910745ebf588026065177b8229c0" title="Get iterator at first item (mutable). ">begin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf" title="Get iterator at end. ">end()</a> </dd></dl>

</div>
</div>
<a id="aa1b61c5914f98f93750fdd0e86b48cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b61c5914f98f93750fdd0e86b48cef">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a> cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at end (const). </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
<li>This really just creates an empty iterator</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at end position </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e" title="Iterator (const) - IteratorRa. ">Iter</a>, <a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#acd53910745ebf588026065177b8229c0" title="Get iterator at first item (mutable). ">begin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa87e8d6522dbd627eb106867c5e3facf" title="Get iterator at end. ">end()</a> </dd></dl>

</div>
</div>
<a id="a0a255b9041ed57db4f1f25adf917dc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a255b9041ed57db4f1f25adf917dc0f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear by removing all items. </p>
<ul>
<li>Does not set list as null &ndash; null status is unchanged</li>
<li>This does not change list size, only sets all items as null</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="ae5cf100657e66fe9b53235efea0c7710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cf100657e66fe9b53235efea0c7710">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result (&lt;0 if this is less, 0 if equal, &gt;0 if this is greater) </dd></dl>

</div>
</div>
<a id="a7da3137afbe1f1068ac1104f132b09b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da3137afbe1f1068ac1104f132b09b1">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set as full (unshared) copy using data pointer (modifier). </p>
<ul>
<li>Effectively calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="aff284a10e589857e1612356637d5d125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff284a10e589857e1612356637d5d125">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>* data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get data pointer for direct access (const). </p>
<ul>
<li><b>Caution:</b> Calling any modifier/mutable method like <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a> after this may (will) invalidate the returned pointer</li>
<li>Result is only valid if <a class="el" href="classevo_1_1_ptr_list.html#acce0ab2cacc475b2434f24c65c91685a" title="Get list size. ">size()</a> &gt; 0, otherwise may be NULL or an invalid internal value</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Data pointer as read-only, NULL/invalid if <a class="el" href="classevo_1_1_ptr_list.html#acce0ab2cacc475b2434f24c65c91685a" title="Get list size. ">size()</a> is 0 (const) </dd></dl>

</div>
</div>
<a id="a59fabf379a400b94b3933f360a58c02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fabf379a400b94b3933f360a58c02c">&#9670;&nbsp;</a></span>dataM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>* dataM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get data pointer (mutable). </p>
<ul>
<li>Calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li><b>Caution:</b> Calling any modifier method like <a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe" title="Resize while preserving existing data (modifier). ">resize()</a> after this may (will) invalidate the returned pointer</li>
<li>For best performance, reuse returned pointer for repeated access, or use <a class="el" href="classevo_1_1_ptr_list.html#aff284a10e589857e1612356637d5d125" title="Get data pointer for direct access (const). ">data()</a> instead for read-only access</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Data pointer (mutable). </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether empty. </p>
<ul>
<li>Empty when <a class="el" href="classevo_1_1_ptr_list.html#acce0ab2cacc475b2434f24c65c91685a" title="Get list size. ">size()</a> is 0 or all items are null</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Whether empty </dd></dl>

</div>
</div>
<a id="aa87e8d6522dbd627eb106867c5e3facf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87e8d6522dbd627eb106867c5e3facf">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6">IterM</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at end. </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
<li>This really just creates an empty iterator</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at end position </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#a532d87f518998bf5e0007aa207aa5ec6" title="Iterator (mutable) - IteratorRa. ">IterM</a>, <a class="el" href="classevo_1_1_ptr_list.html#acd53910745ebf588026065177b8229c0" title="Get iterator at first item (mutable). ">begin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#ac489717f3b69c08171c3e96001c346d1" title="Get iterator at first item (const). ">cbegin()</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef" title="Get iterator at end (const). ">cend()</a> </dd></dl>

</div>
</div>
<a id="ad2cae394a7c7691f05878ed4ca9f001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cae394a7c7691f05878ed4ca9f001b">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a77d22e6961fb9ba9899db498fd226d4e">Iter</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator at end (const). </p>
<ul>
<li>This allows compatibility with range-based for loops and other libraries, otherwise use container Iter directly</li>
<li>This really just creates an empty iterator</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Iterator at end position </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevo_1_1_ptr_list.html#a5ba0fc6e8555617fd28b156f3b428093" title="Get iterator at first item (const). ">begin() const</a>, <a class="el" href="classevo_1_1_ptr_list.html#aa1b61c5914f98f93750fdd0e86b48cef" title="Get iterator at end (const). ">cend()</a> </dd></dl>

</div>
</div>
<a id="a13d5f20caa825eef1823584895ad3b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d5f20caa825eef1823584895ad3b2c">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code><a class="el" href="group___evo_core.html#ga72f5a71bcf1f982c309cc4410a01ba81">END</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first occurrence of item with forward search. </p>
<ul>
<li>This searches non-null items for given value, using item operator==() for comparisons</li>
<li>Search stops before reaching end index or end of list</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to find </td></tr>
    <tr><td class="paramname">start</td><td>Starting index for search </td></tr>
    <tr><td class="paramname">end</td><td>End index for search, END for end of list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found item index or NONE if not found </dd></dl>

</div>
</div>
<a id="a13054f08a6851a8faf26d6fb4fe45886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13054f08a6851a8faf26d6fb4fe45886">&#9670;&nbsp;</a></span>findr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> findr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code><a class="el" href="group___evo_core.html#ga72f5a71bcf1f982c309cc4410a01ba81">END</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find last occurrence of item with reverse search. </p>
<ul>
<li>This searches non-null items for given value, using item operator==() for comparisons</li>
<li>Same as <a class="el" href="classevo_1_1_ptr_list.html#a13d5f20caa825eef1823584895ad3b2c" title="Find first occurrence of item with forward search. ">find()</a> but does reverse search starting right before end index, or at last item if end of list</li>
<li>As with <a class="el" href="classevo_1_1_ptr_list.html#a13d5f20caa825eef1823584895ad3b2c" title="Find first occurrence of item with forward search. ">find()</a>, item at end index is not checked</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Item to find </td></tr>
    <tr><td class="paramname">start</td><td>Starting index for search range &ndash; last item checked in reverse search </td></tr>
    <tr><td class="paramname">end</td><td>End index for search range (reverse search starting point), END for end of list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found item index or NONE if not found </dd></dl>

</div>
</div>
<a id="a7db168fe0a939de2cd0dca14eaaf49ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db168fe0a939de2cd0dca14eaaf49ca">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get first non-null item (const). </p>
<ul>
<li>For best performance store result rather than calling repeatedly</li>
<li><b>Caution:</b> Any operation that changes</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>First item pointer, NULL if empty or all items null </dd></dl>

</div>
</div>
<a id="ae67d1dc5a5ca1d5a78e11de3ad36c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67d1dc5a5ca1d5a78e11de3ad36c3ec">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a34b57a974fe67a997b7693e6e71cd904">Value</a>&amp; get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>created</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item value for key, creating if needed (mutable). </p>
<ul>
<li>Calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li>Item is created with default value if not found</li>
<li>This grows list as needed using <a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe" title="Resize while preserving existing data (modifier). ">resize()</a> if item key is too small to fit</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key (index) to use </td></tr>
    <tr><td class="paramname">created</td><td>Stores whether new item was created, if not NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value reference for key </dd></dl>

</div>
</div>
<a id="ad723d39c44b7064a6be92369e755c818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad723d39c44b7064a6be92369e755c818">&#9670;&nbsp;</a></span>getitem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> getitem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>created</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item for key, creating if needed (mutable). </p>
<ul>
<li>Calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li>Item is created with default value if not found</li>
<li>This grows list as needed using <a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe" title="Resize while preserving existing data (modifier). ">resize()</a> if item key is too small to fit</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key (index) to use </td></tr>
    <tr><td class="paramname">created</td><td>Stores whether new item was created, if not NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item pointer for key </dd></dl>

</div>
</div>
<a id="ad80a61d0d69ea6a2b996492cf2259917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a61d0d69ea6a2b996492cf2259917">&#9670;&nbsp;</a></span>iend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a> iend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get index for last item position using offset. </p>
<ul>
<li>This simplifies math when computing an index from last item position</li>
<li>This uses the formula: iend = size - 1 - offset</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from end, 0 for last item, 1 for second-last, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting index, END if offset out of bounds </dd></dl>

</div>
</div>
<a id="a0c776383302f9c1d6c28678849f17d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c776383302f9c1d6c28678849f17d89">&#9670;&nbsp;</a></span>item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at position (const). </p>
<ul>
<li>This is a pointer list so the given item can be null</li>
<li><b>Caution:</b> Results are undefined if index is out of bounds</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Item index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given item as read-only pointer, NULL if item is null (const) </dd></dl>

</div>
</div>
<a id="a0ece36cd56ac4e9e81c382aaeb6bfad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ece36cd56ac4e9e81c382aaeb6bfad8">&#9670;&nbsp;</a></span>itemM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> itemM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at position (mutable). </p>
<ul>
<li>Calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li>This is a pointer list so the given item can be null</li>
<li>This doesn't allow modifying the stored pointer, for that use <a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec" title="Get item value for key, creating if needed (mutable). ">get()</a></li>
<li>For best performance, use <a class="el" href="classevo_1_1_ptr_list.html#a59fabf379a400b94b3933f360a58c02c" title="Get data pointer (mutable). ">dataM()</a> once for repeated item access, or <a class="el" href="classevo_1_1_ptr_list.html#a0c776383302f9c1d6c28678849f17d89" title="Get item at position (const). ">item()</a> for read-only access</li>
<li><b>Caution:</b> Results are undefined if index is out of bounds &ndash; though index is checked with assert()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Item index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given item pointer, NULL if item is null (mutable) </dd></dl>

</div>
</div>
<a id="a676580448265761be440acc7aeff1954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676580448265761be440acc7aeff1954">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get last non-null item (const). </p>
<ul>
<li>The last non-null item does not necessarilly mean the very last item in list</li>
<li>For best performance store result rather than calling repeatedly</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Last item pointer, NULL if empty or all items null </dd></dl>

</div>
</div>
<a id="a5fc3ccc049f9327dc84116f44bde5c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3ccc049f9327dc84116f44bde5c26">&#9670;&nbsp;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether null. </p>
<ul>
<li>Always empty when null</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Whether null </dd></dl>

</div>
</div>
<a id="ade9e807f7f885259f9ba23798808dbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9e807f7f885259f9ba23798808dbe9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<ul>
<li>Items are compared with operator==()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether inequal </dd></dl>

</div>
</div>
<a id="a14e2fe286c8d433180b4884e0e957d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e2fe286c8d433180b4884e0e957d10">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at position (mutable). </p>
<ul>
<li>Calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li>This is a pointer list so the given item can be null</li>
<li>This doesn't allow modifying the stored pointer, for that use <a class="el" href="classevo_1_1_ptr_list.html#ae67d1dc5a5ca1d5a78e11de3ad36c3ec" title="Get item value for key, creating if needed (mutable). ">get()</a></li>
<li>For best performance, use <a class="el" href="classevo_1_1_ptr_list.html#a59fabf379a400b94b3933f360a58c02c" title="Get data pointer (mutable). ">dataM()</a> once for repeated item access, or <a class="el" href="classevo_1_1_ptr_list.html#a0c776383302f9c1d6c28678849f17d89" title="Get item at position (const). ">item()</a> for read-only access</li>
<li><b>Caution:</b> Results are undefined if index is out of bounds &ndash; though index is checked with assert()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Item index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given item pointer, NULL if item is null (mutable) </dd></dl>

</div>
</div>
<a id="af1b94f01d07c02f63bdba2b782732674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b94f01d07c02f63bdba2b782732674">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator (C++11). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="ae6c82138bee897766f29d30eec053a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c82138bee897766f29d30eec053a81">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<ul>
<li>Makes shared copy if possible &ndash; see <a class="el" href="_sharing.html">Sharing</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="ae3e876e0fa5f273131cda34e2083743b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e876e0fa5f273131cda34e2083743b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<ul>
<li>Items are compared with operator==()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether equal </dd></dl>

</div>
</div>
<a id="ac9a09ad8db07d71a9d15d4f7920e99ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a09ad8db07d71a9d15d4f7920e99ce">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at position (const). </p>
<ul>
<li>This is a pointer list so the given item can be null</li>
<li><b>Caution:</b> Results are undefined if index is out of bounds</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Item index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given item as read-only pointer, NULL if item is null (const) </dd></dl>

</div>
</div>
<a id="a6e5b3a8116984dc3f19ad9bc9d9c1616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5b3a8116984dc3f19ad9bc9d9c1616">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a042bda8b98e14936d8741ace1bd3b954">Key</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove item and set as null (modifier). </p>
<ul>
<li>Effectively calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li>The removed item is set as null &ndash; no change to list size</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Item key (index) to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="a10e90947ff4c0b0a10ad2e42373f6ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e90947ff4c0b0a10ad2e42373f6ebe">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize while preserving existing data (modifier). </p>
<ul>
<li>This adds/removes items as needed until given size is reached</li>
<li>Effectively calls <a class="el" href="classevo_1_1_ptr_list.html#a0b133eb243fa5845996a312890eeb305" title="Make sure data is not shared by allocating new buffer if needed (modifier). ">unshare()</a></li>
<li><b>Advanced:</b> See advBuffer() for getting writable pointer to buffer</li>
<li><b>Advanced:</b> See advResize() for best performance in certain POD cases</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newsize</td><td>New size as item count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="ab17cabe5df6f4c4216e5676e08593d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17cabe5df6f4c4216e5676e08593d43">&#9670;&nbsp;</a></span>resizemin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; resizemin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a>&#160;</td>
          <td class="paramname"><em>minsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize to minimum size while preserving existing data (modifier). </p>
<ul>
<li>This calls <a class="el" href="classevo_1_1_ptr_list.html#a10e90947ff4c0b0a10ad2e42373f6ebe" title="Resize while preserving existing data (modifier). ">resize()</a> if current size is smaller than minimum</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minsize</td><td>Minimum size as item count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="a219a41ab8fb6246ea2bc13678191cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219a41ab8fb6246ea2bc13678191cc79">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set as null and empty. </p>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="aec9a049e8455daa831bd28ebf1e93558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9a049e8455daa831bd28ebf1e93558">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set from another list. </p>
<ul>
<li>Makes shared copy if possible &ndash; see <a class="el" href="_sharing.html">Sharing</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to set/copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="ae48db32319ac5d88b4da288304f50efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48db32319ac5d88b4da288304f50efe">&#9670;&nbsp;</a></span>setempty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; setempty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set as empty but not null. </p>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="acb3e912f111aeca639e8ca31a63ad5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3e912f111aeca639e8ca31a63ad5ec">&#9670;&nbsp;</a></span>shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether shared. </p>
<ul>
<li><a class="el" href="classevo_1_1_list.html" title="Sequential list container with random access. ">List</a> is shared when a buffer is allocated and shared (reference count &gt; 1)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Whether shared </dd></dl>

</div>
</div>
<a id="acce0ab2cacc475b2434f24c65c91685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce0ab2cacc475b2434f24c65c91685a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list size. </p>
<dl class="section return"><dt>Returns</dt><dd>Size as item count </dd></dl>

</div>
</div>
<a id="a6d3584c7b7893bbc584668a9d5be81c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3584c7b7893bbc584668a9d5be81c7">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap with another list. </p>
<ul>
<li>This swaps internal state directly for best performance</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b133eb243fa5845996a312890eeb305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b133eb243fa5845996a312890eeb305">&#9670;&nbsp;</a></span>unshare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a8a35c554ff33fcf76b537a78429f45df">ThisType</a>&amp; unshare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure data is not shared by allocating new buffer if needed (modifier). </p>
<ul>
<li>Use to make buffer unique (not shared) and writable (when not empty)</li>
<li>This is called automatically by mutable/modifier methods</li>
<li>This does nothing if empty or not shared</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>This </dd></dl>

</div>
</div>
<a id="a6a4820f826e79735c2e056b8e810dcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4820f826e79735c2e056b8e810dcac">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list used size, number of non-null items. </p>
<dl class="section return"><dt>Returns</dt><dd>Used size as item count </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a053cc96ea6f4a88d23c99fd7b4eb73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053cc96ea6f4a88d23c99fd7b4eb73e6">&#9670;&nbsp;</a></span>data_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a919f5c9d036735eb0f28040842847a38">Item</a>* data_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data pointer, NULL if null, can be 1 if empty (size_=0) </p>

</div>
</div>
<a id="ab27da035d0d3c1313bae9f65d2e3c145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27da035d0d3c1313bae9f65d2e3c145">&#9670;&nbsp;</a></span>header_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevo_1_1_ptr_list_1_1_header.html">Header</a>* header_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data header pointer, NULL if no buffer allocated. </p>

</div>
</div>
<a id="af413506ef7c7376c1ea8ca4622cb1ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af413506ef7c7376c1ea8ca4622cb1ada">&#9670;&nbsp;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevo_1_1_ptr_list.html#a6480de157f9f73b69befd00d0545dd70">Size</a> size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data size (same as header.size), 0 if empty. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>evo/<a class="el" href="ptrlist_8h_source.html">ptrlist.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 7 2019 18:17:39 for Evo C++ Library v0.5.1 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
